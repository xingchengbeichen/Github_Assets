//第一章  操作系统
//操作系统的定义
  //负责管理协调硬件、软件等计算机资源的工作，为上层用户、应用程序提供简单易用的服务，是一种系统软件。
//操作系统的功能
  //1.资源的管理者：处理机资源、存储器资源、文件资源、设备资源；
  /*2.向上层提供服务：给普通用户提供GUI用户图形界面和命令接口（联机命令接口，如cmd命令、
    脱机命令接口，如.bat文件）、给软件和程序员用的程序接口（即系统调用）；*/
  //3.对硬件机器扩展，即扩充机器（虚拟机）。
//操作系统的特征
  //1.并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。
    //常考易混概念——并行:指两个或多个事件在同一时刻同时发生。
  //2.共享：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。（互斥共享方式、同时共享方式）
  //3.虚拟：是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。
    //如虚拟存储器（空分复用技术）、虚拟处理器（时分复用技术）
  /*4.异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，
    这就是进程的异步性。*/

//操作系统运行机制
//两种指令
  //特权指令：只能在内核态执行的指令（开关中断、写时钟、输入输出、写PSW（程序状态字寄存器））。
  //非特权指令：能在用户态执行的指令（存取数、读时钟、加减乘除、寄存器清零、压栈弹栈、跳转、trap（访管））。
//两种处理机状态
  //用户态（目态）：处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令
  //内核态（管态）：处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令
//两种程序
  //内核程序、应用程序
//内核态->用户态：一条修改psw（程序状态字寄存器）的特权指令
//用户态->内核态：由中断引起，硬件自动完成（中断是操作系统内核夺回CPU使用权的唯一途径）

//中断和异常
//终端的分类
  //1.内中断（或异常、例外）：陷入，陷阱（trap）、故障（fault）、终止（abort）2.外中断（或中断）：时钟中断、I/O中断请求

//系统调用
  //操作系统对应用程序/程序员提供的接口
//库函数和系统调用的区别：1.库函数是对系统调用的进一步封装；2.有的库函数没有使用系统调用
//系统调用的功能：1.设备管理；2.文件管理；3.进程控制；4.进程通信；5.内存管理
//系统调用的过程：1.传参；2.执行陷入指令/trap指令/访管指令；3.由操作系统内核程序处理系统调用请求；4.返回应用程序


//第二章  进程
//进程的定义
  //进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

//进程(Process)和程序：进程是动态的，是程序的一次执行过程；程序是静态的，就是存放在磁盘里的可执行文件，是一系列指令的集合
/*操作系统对每个进程分配PID、UID并记录分配的资源（内存使用、I/O设备使用、文件使用）、进程的运行情况（CPU使用时间、磁盘使用情况、
  网络流量使用情况）等，这些信息都被保存在一个数据结构PCB(Process Control Block)中，即进程控制块。*/
//注意：PCB是进程存在的唯一标识
//一个进程实体（进程映像）由PCB、程序段、数据段组成；进程是动态的，进程实体（进程映像）是静态的

//进程的特征
  //动态性、并发性、独立性、异步性、结构性
//进程的状态
  //创建态、就绪态、运行态、阻塞态、终止态

//进程间通信(Inter-Process Communication，IPC)
//进程间通信的方式
  //共享存储：基于数据结构的共享、基于存储区的共享
  //消息传递：直接通信方式、间接（信箱）通信方式
  //管道通信(特点：FIFO，半双工通信)：管道中数据一旦被读出就彻底消失，为防止数据错乱
    //1.一个管道允许多个写进程和一个读进程
    //2.允许有多个写进程和多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux方案）

//进程调度算法的评价指标
  //CPU利用率=忙碌时间/总时间
  //系统吞吐量=总共完成了多少道作业/总共花了多少时间
  //周转时间=作业完成时间-作业提交时间
  //平均周转时间=各作业周转时间之和/作业数
  //带权周转时间=作业周转时间/作业实际运行的时间
  //平均带权周转时间=个作业带权周转时间之和/作业数

//进程的同步与互斥
  //思想：空闲让进；忙则等待；有限等待；让权等待
//进程互斥的软件实现方法
  //单标志法
    //思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予。
    //同一时刻最多只允许一个进程访问临界资源
int turn=0;              //turn表示当前允许进入临界区的进程编号
//P0进程
void P0(){
  while(turn!=0);        //进入区
  critical section;      //临界区
  turn=1;                //推出区
  remainder section;     //剩余区
}
//P1进程
void P1(){
  while(turn!=1);
  critical section;
  turn=0;
  remainder section;
}                         //违反“空闲让进”原则

  //双标志先检查法
    /*思想：设置一个bool型数组flag[]，数组中各元素用来标记各进程想进入临界区的意愿。
      每个进程在进入临界区时先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设置为true*/
bool flag[2];             //表示进入临界区意愿的数组
flag[0]=false;
flag[1]=false;
//P0进程
void P0(){
  while(flag[1]);         //首先判断P1进程是否想进入临界区
  flag[0]=true;           //将自身想进入临界区的数组设置为true
  critical section;       //访问临界区
  flag[0]=false;          //访问完临界区后修改标记
  remainder section;
}
//P1进程
void P1(){
  while(flag[0]);
  flag[1]=true;
  critical section;
  flag[1]false;
  remainder section;
}                          //违反“忙则等待”原则

  //双标志后检查法
bool flag[2];              //进入临界区意愿的数组
flag[0]=false;
flag[1]=false;
//P0进程
void P0(){
  flag[0]=true;            //标记P0进程想要进入临界区
  while(flag[1]);          //如果P1进程也想进入临界区，则P0循环等待
  critical section;        //访问临界区
  flag[0]=false;           //访问完临界区后修改标记
  remainder section;
}
//P1进程
void P1(){
  flag[1]=true;
  while(flag[0]);
  cirtical section;
  flag[1]false;
  remainder section;
}                            //违背了“空闲让进”和“有限等待”原则

  //Peterson算法
bool flag[2];                //表示进入临界区意愿的数组，初始都是false
flag[0]=false;
flag[1]=false;
int turn=0;                  //turn表示优先让那个进程进入临界区
//P0进程
void P0(){
  flag[0]=true;              //表示自己想进入临界区
  turn=1;                    //可以优先让对方进入临界区
  while(flag[1]&&turn==1);   //对方想进，且最后一次是自己“让梨”，那自己就循环等待
  cirtical section;
  flag[0]=false;
  remainder section;
};
//P1进程
void P1(){
  flag[1]=true;
  turn=0;
  while(flag[0]&&turn==0);
  critical section;
  flag[1]=false;
  remainder section;
}                             //违反了“让权等待”原则

//进程互斥的硬件实现方法
  //终端屏蔽方法

  //TestAndSet指令(Ts指令)(或TestAndSetLock,TSL指令)
//bool型共享变量lock表示当前临界区是否被加锁
//true表示已加锁，false表示未加锁
bool TestAndSet(bool *lock){
  bool old;
  old=*lock;                   //old用来存放原来的值
  *lock=true;                  //无论之前是否已经加锁，都将lock设置为true
  return old;                  //返回lock原来的值
}
//以下是使用TSL指令实现互斥的算法逻辑
while(TestAndSet(&lock));      //"上锁"并“检查”
临界区代码
lock=false;                    //"解锁"
剩余区代码                      //违反了“让权等待”原则

  //swap指令（Exchange指令，或简称XCHG指令）
//swap指令的作用是交换两个指令的值
Swap(bool *a,bool *b){
  bool temp;
  temp=*a;
  *a=*b;
  *b=temp;
}
//以下是用Swapv指令实现互斥的算法逻辑
//lock表示当前临界区是否被加锁
bool old=true;
while(old==true)
  Swap(&lock,&old);
临界区代码段
lock=false;
剩余区代码段                    //违反了“让权等待”原则

//信号量机制
  //整型信号量（不满足“让权等待”原则）
int s=1;                       //初始化整型信号量，表示当前系统中可使用的打印机数量
void wait(int s){              //wait原语，相当于“进入区”
  while(s<=0);                 //如果资源数量不够，就一直等待
  s=s-1;                       //如果资源数量够，则占用一个临界资源
}
void signal(int s){            //signal原语，相当于“退出区”
  s=s+1;                       //试用完资源后，在退出区释放资源
}
//P0进程
void P0(){
  wait(s);                      //进入临界区，申请资源
  使用打印机资源                 //临界区，访问资源
  signal(s);                    //退出区，释放资源
}
//P1进程
void P1(){
  wait(s);
  使用打印机资源
  signal(s);
}

  //记录型信号量
//记录型信号量的定义
typedef struct{
  int value;                //剩余资源数
  struct process *L;        //等待队列
}semaphore;
//使用wait原语申请需要使用的资源
void wait(semaphore s){
  s.value--;
  if(s.value<0){
    block(s.L);
  }
}
//使用signal原语释放使用完的资源
void signal(semaphore s){
  s.value++;
  if(s.value<=0){
    wakeup(s.L);
  }
}
