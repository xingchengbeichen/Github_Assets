//第一章  操作系统
//操作系统的定义
  //负责管理协调硬件、软件等计算机资源的工作，为上层用户、应用程序提供简单易用的服务，是一种系统软件。
//操作系统的功能
  //1.资源的管理者：处理机资源、存储器资源、文件资源、设备资源；
  /*2.向上层提供服务：给普通用户提供GUI用户图形界面和命令接口（联机命令接口，如cmd命令、
    脱机命令接口，如.bat文件）、给软件和程序员用的程序接口（即系统调用）；*/
  //3.对硬件机器扩展，即扩充机器（虚拟机）。
//操作系统的特征
  //1.并发：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。
    //常考易混概念——并行:指两个或多个事件在同一时刻同时发生。
  //2.共享：即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。（互斥共享方式、同时共享方式）
  //3.虚拟：是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者）是用户感受到的。
    //如虚拟存储器（空分复用技术）、虚拟处理器（时分复用技术）
  /*4.异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，
    这就是进程的异步性。*/

//操作系统运行机制
//两种指令
  //特权指令：只能在内核态执行的指令（开关中断、写时钟、输入输出、写PSW（程序状态字寄存器））。
  //非特权指令：能在用户态执行的指令（存取数、读时钟、加减乘除、寄存器清零、压栈弹栈、跳转、trap（访管））。
//两种处理机状态
  //用户态（目态）：处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令
  //内核态（管态）：处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令
//两种程序
  //内核程序、应用程序
//内核态->用户态：一条修改psw（程序状态字寄存器）的特权指令
//用户态->内核态：由中断引起，硬件自动完成（中断是操作系统内核夺回CPU使用权的唯一途径）

//中断和异常
//终端的分类
  //1.内中断（或异常、例外）：陷入，陷阱（trap）、故障（fault）、终止（abort）2.外中断（或中断）：时钟中断、I/O中断请求

//系统调用
  //操作系统对应用程序/程序员提供的接口
//库函数和系统调用的区别：1.库函数是对系统调用的进一步封装；2.有的库函数没有使用系统调用
//系统调用的功能：1.设备管理；2.文件管理；3.进程控制；4.进程通信；5.内存管理
//系统调用的过程：1.传参；2.执行陷入指令/trap指令/访管指令；3.由操作系统内核程序处理系统调用请求；4.返回应用程序


//第二章  进程
//进程的定义
  //进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位

//进程(Process)和程序：进程是动态的，是程序的一次执行过程；程序是静态的，就是存放在磁盘里的可执行文件，是一系列指令的集合
/*操作系统对每个进程分配PID、UID并记录分配的资源（内存使用、I/O设备使用、文件使用）、进程的运行情况（CPU使用时间、磁盘使用情况、
  网络流量使用情况）等，这些信息都被保存在一个数据结构PCB(Process Control Block)中，即进程控制块。*/
//注意：PCB是进程存在的唯一标识
//一个进程实体（进程映像）由PCB、程序段、数据段组成；进程是动态的，进程实体（进程映像）是静态的

//进程的特征
  //动态性、并发性、独立性、异步性、结构性
//进程的状态
  //创建态、就绪态、运行态、阻塞态、终止态

//进程间通信(Inter-Process Communication，IPC)
//进程间通信的方式
  //共享存储：基于数据结构的共享、基于存储区的共享
  //消息传递：直接通信方式、间接（信箱）通信方式
  //管道通信(特点：FIFO，半双工通信)：管道中数据一旦被读出就彻底消失，为防止数据错乱
    //1.一个管道允许多个写进程和一个读进程
    //2.允许有多个写进程和多个读进程，但系统会让各个读进程轮流从管道中读数据（Linux方案）

//进程调度算法的评价指标
  //CPU利用率=忙碌时间/总时间
  //系统吞吐量=总共完成了多少道作业/总共花了多少时间
  //周转时间=作业完成时间-作业提交时间
  //平均周转时间=各作业周转时间之和/作业数
  //带权周转时间=作业周转时间/作业实际运行的时间
  //平均带权周转时间=个作业带权周转时间之和/作业数

//进程的同步与互斥
  //思想：空闲让进；忙则等待；有限等待；让权等待
//进程互斥的软件实现方法
  //单标志法
    //思想：两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，也就是说每个进程进入临界区的权限只能被另一个进程赋予。
    //同一时刻最多只允许一个进程访问临界资源
int turn=0;              //turn表示当前允许进入临界区的进程编号
//P0进程
void P0(){
  while(turn!=0);        //进入区
  critical section;      //临界区
  turn=1;                //推出区
  remainder section;     //剩余区
}
//P1进程
void P1(){
  while(turn!=1);
  critical section;
  turn=0;
  remainder section;
}                         //违反“空闲让进”原则

  //双标志先检查法
    /*思想：设置一个bool型数组flag[]，数组中各元素用来标记各进程想进入临界区的意愿。
      每个进程在进入临界区时先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志flag[i]设置为true*/
bool flag[2];             //表示进入临界区意愿的数组
flag[0]=false;
flag[1]=false;
//P0进程
void P0(){
  while(flag[1]);         //首先判断P1进程是否想进入临界区
  flag[0]=true;           //将自身想进入临界区的数组设置为true
  critical section;       //访问临界区
  flag[0]=false;          //访问完临界区后修改标记
  remainder section;
}
//P1进程
void P1(){
  while(flag[0]);
  flag[1]=true;
  critical section;
  flag[1]false;
  remainder section;
}                          //违反“忙则等待”原则

  //双标志后检查法
bool flag[2];              //进入临界区意愿的数组
flag[0]=false;
flag[1]=false;
//P0进程
void P0(){
  flag[0]=true;            //标记P0进程想要进入临界区
  while(flag[1]);          //如果P1进程也想进入临界区，则P0循环等待
  critical section;        //访问临界区
  flag[0]=false;           //访问完临界区后修改标记
  remainder section;
}
//P1进程
void P1(){
  flag[1]=true;
  while(flag[0]);
  cirtical section;
  flag[1]false;
  remainder section;
}                            //违背了“空闲让进”和“有限等待”原则

  //Peterson算法
bool flag[2];                //表示进入临界区意愿的数组，初始都是false
flag[0]=false;
flag[1]=false;
int turn=0;                  //turn表示优先让那个进程进入临界区
//P0进程
void P0(){
  flag[0]=true;              //表示自己想进入临界区
  turn=1;                    //可以优先让对方进入临界区
  while(flag[1]&&turn==1);   //对方想进，且最后一次是自己“让梨”，那自己就循环等待
  cirtical section;
  flag[0]=false;
  remainder section;
};
//P1进程
void P1(){
  flag[1]=true;
  turn=0;
  while(flag[0]&&turn==0);
  critical section;
  flag[1]=false;
  remainder section;
}                             //违反了“让权等待”原则

//进程互斥的硬件实现方法
  //终端屏蔽方法

  //TestAndSet指令(Ts指令)(或TestAndSetLock,TSL指令)
//bool型共享变量lock表示当前临界区是否被加锁
//true表示已加锁，false表示未加锁
bool TestAndSet(bool *lock){
  bool old;
  old=*lock;                   //old用来存放原来的值
  *lock=true;                  //无论之前是否已经加锁，都将lock设置为true
  return old;                  //返回lock原来的值
}
//以下是使用TSL指令实现互斥的算法逻辑
while(TestAndSet(&lock));      //"上锁"并“检查”
临界区代码
lock=false;                    //"解锁"
剩余区代码                      //违反了“让权等待”原则

  //swap指令（Exchange指令，或简称XCHG指令）
//swap指令的作用是交换两个指令的值
Swap(bool *a,bool *b){
  bool temp;
  temp=*a;
  *a=*b;
  *b=temp;
}
//以下是用Swapv指令实现互斥的算法逻辑
//lock表示当前临界区是否被加锁
bool old=true;
while(old==true)
  Swap(&lock,&old);
临界区代码段
lock=false;
剩余区代码段                    //违反了“让权等待”原则

//信号量机制
  //整型信号量（不满足“让权等待”原则）
int s=1;                       //初始化整型信号量，表示当前系统中可使用的打印机数量
void wait(int s){              //wait原语，相当于“进入区”
  while(s<=0);                 //如果资源数量不够，就一直等待
  s=s-1;                       //如果资源数量够，则占用一个临界资源
}
void signal(int s){            //signal原语，相当于“退出区”
  s=s+1;                       //试用完资源后，在退出区释放资源
}
//P0进程
void P0(){
  wait(s);                      //进入临界区，申请资源
  使用打印机资源                 //临界区，访问资源
  signal(s);                    //退出区，释放资源
}
//P1进程
void P1(){
  wait(s);
  使用打印机资源
  signal(s);
}

  //记录型信号量
//记录型信号量的定义
typedef struct{
  int value;                //剩余资源数
  struct process *L;        //等待队列
}semaphore;
//使用wait原语申请需要使用的资源
void wait(semaphore s){
  s.value--;
  if(s.value<0){
    block(s.L);
  }
}
//使用signal原语释放使用完的资源
void signal(semaphore s){
  s.value++;
  if(s.value<=0){
    wakeup(s.L);
  }
}

//信号量机制实现进程互斥
typedef struct{              //定义信号量结构体
  int value;
  struct process *L;
}semaphore;
semaphore mutex=1;           //初始化信号量
//P0进程
P0(){
  p(mutex);
  临界区代码段
  V(mutex);
}
//P1进程
P1(){
  P(mutex);
  临界区代码段
  V(mutex);
}

//信号量机制实现进程同步
semaphore S=0;                //初始化同步信号量为0
P0(){
  代码1;
  代码2;
  V(S);
  代码3;
}
P1(){
  V(S);
  代码4;
  代码5;
  代码6;
}

//经典的PV操作问题
//生产者-消费者问题
  /*系统中有一组生产者进程和一组消费者进程，生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用 。
    (注:这里的“产品”理解为某种数据)*/
  //1.生产者、消费者共享一个初始为空、大小为n的缓冲区。
  //2.只有缓冲区没满时，生产者才能把产品放入缓冲区，否则必须等待。
  //3.只有缓冲区不空时，消费者才能从中取出产品，否则必须等待。
  //4.缓冲区是临界资源，各进程必须互斥地访问。
semaphore full=0;                //同步信号量，表示产品数量，也即非空缓冲区的数量
semaphore empty=n;               //同步信号量，表示空闲缓冲区的数量
semaphore mutex=1;               //互斥信号量，实现各进程对缓冲区的互斥访问
Producer(){                      //生产者进程
  while(1){
    生产一个产品;
    P(empty);                    //消耗一个空缓冲区
    P(mutex);                    //读写进程互斥访问缓冲区
    把产品放入空闲缓冲区;
    v(mutex);                    //解锁
    V(full);                     //产生一个非空缓冲区
  }
}
Consumer(){                      //消费者进程
  while(1){
    P(full);                     //消耗一个非空缓冲区
    P(mutex);                    //读写进程互斥访问缓冲区
    从非空缓冲区取一个商品;
    V(mutex);                    //解锁
    V(empty);                    //产生一个空缓冲区
    消耗一个产品;
  }
}                                //为避免死锁，实现互斥的P操作要在实现同步的P操作之后

//多生产者-多消费者问题
semaphore mutex=1;               //定义互斥信号量
semaphore s1=0;                  //同步信号量，生产和消费的第一类产品
semaphore s2=0;                  //同步信号量，生产和消费的第二类产品
semaphore buffer=2;              //同步信号量，缓冲区大小
Producer1(){                     //第一类产品的生产者
  while(1){
    生产一个产品1;
    P(buffer);
    P(mutex);
    把产品1放入空闲缓冲区;
    V(mutex);
    V(s1);
  }
}
Producer2(){                       //第二类产品生产者
  while(1){
    生产一个产品2;
    P(buffer);
    P(mutex);
    把产品2放入空闲缓冲区；
    V(mutex);
    V(s2);
  }
}
consumer1(){                       //第一类产品消费者
  while(1){
    P(s1);
    P(mutex);
    从缓冲区取出产品1;
    V(mutex);
    V(buffer);
    消耗一个产品1;
  }
}
consumer2(){                        //第二类产品消费者
  while(1){
    P(s2);
    P(mutex);
    从缓冲区去除产品2;
    V(mutex);
    V(buffer);
    消耗一个产品2;
  }
}

//读者-写者问题
  /*有读者和写者两组并发进程，共享一个文件，当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程
    （读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求*/
  //1.允许多个读者可以同时对文件执行读操作；
  //2.只允许一个写者往文件中写信息；
  //3.任一写者在完成写操作之前不允许其他读者或写者工作；
  //4.写者执行写操作前，应让已有的读者和写者全部退出。
semaphore rw=1;                     //互斥信号量，用来实现对共享文件的互斥访问
int count=0;                        //由于读进程之间不互斥，故定义一个整型变量记录读进程数量
semaphore mutex=1;                  //由于对count变量的判断和加减操作无法一气呵成，故需要互斥信号量对count变量互斥访问
writer(){                           //写进程
  while(1){
    P(rw);                          //写之前“上锁”
    写文件;
    V(rw);                          //写之后“解锁”
  }
}
reader(){                           //读进程
  while(1){
    P(mutex);
    if(count==0)                    //判断是否为第一个读者进程
      P(rw);
    count++;                        //读者进程数量加1
    V(mutex);
    读文件;
    P(mutex);
    count--;                        //读者进程数量减1
    if(count==0)                    //判断是否为最后一个读者进程
      V(rw);
    V(mutex);
  }
}
//代码存在读者优先，而写者饥饿的问题，优化如下
semaphore rw=1;                     //互斥信号量，用来实现对共享文件的互斥访问
int count=0;                        //由于读进程之间不互斥，故定义一个整型变量记录读进程数量
semaphore mutex=1;                  //由于对count变量的判断和加减操作无法一气呵成，故需要互斥信号量对count变量互斥访问
semaphore w=1;                      //用于实现“写者优先”
writer(){
  while(1){
    P(w);
    P(rw);
    写文件;
    V(rw);
    V(w);
  }
}
reader(){
  while(1){
    P(w);
    P(mutex);
    if(count==0)
      P(rw);
    count++;
    V(mutex);
    V(w);
    读文件；
    P(mutex);
    count--;
    if(count==0)
      V(rw);
    V(mutex);
  }
}

//哲学家进餐问题
semaphore chopstick[5]={1,1,1,1,1};                 //每位哲学家左右两边各有一只筷子，即一种临界资源
semaphore mutex=1;                                  //哲学家进程互斥地拿筷子
Pi(){                                               //第i位哲学家进程
  while(1){
    P(mutex);
    P(chopstick[i]);                                //拿起左边的筷子
    P(chopstick[(i+1)%5]);                          //拿起右边的筷子
    V(mutex);
    吃饭;
    V(chopstick[i]);                                //放下左边的筷子
    V(chopstick[(i+1)%5]);                          //放下右边的筷子
    思考;
  }
}
//方法2
semaphore chopstick[5]={1,1,1,1,1};                 //每位哲学家左右两边各有一只筷子，即一种临界资源
semaphore num=4;                                    //为避免死锁，同一时刻最多只允许4位哲学家进程拿筷子
Pi(){
  while(1){
    P(num);
    P(chopstick[i]);
    P(chopstick[(i+1)%5]);
    吃饭;
    V(chopstick[i]);
    V(chopstick[(i+1)%5]);
    思考;
  }
}
//方法3
semaphore chopstick[5]={1,1,1,1,1};                 //每位哲学家左右两边各有一只筷子，即一种临界资源
int i;                                              //定义整型变量i，表示第i位哲学家
Pi(){
  while(1){
    if(i%2==0){                                     //偶数位哲学家先拿右侧筷子，再拿左侧筷子
      P(chopstick[(i+1)%5]);
      P(chopstick[i]);
    }else{                                          //奇数位哲学家先拿左侧筷子，再拿右侧筷子
      P(chopstick[i]);
      P(chopstick[(i+1)%5]);
    }
    吃饭;
    V(chopstick[i]);
    V(chopstick[(i+1)%5]);
    思考;
  }
}
//管程
//管程的引入是为了解决信号量机制编程麻烦、易出错的问题
//组成：1.共享数据结构；2.对数据结构初始化的语句；3.一组用来访问数据结构的过程(函数)
//基本特征：1.各进程必须互斥访问管程的特性是由编译器实现的；2.可在管程中设置条件变量及等待/唤醒操作以解决同步问题
//补充：1.各外部进程/线程只能通过管程提供的特定“入口”才能访问共享数据；2.每次仅允许一个进程在管程内执行某个内部过程
monitor ProducerConsumer
  condition full,empty;                             //条件变量用来实现同步(排队)
  int count=0;                                      //缓冲区中的产品数
  void insert (Item item){                          //把产品item放入缓冲区
    if (count == N)
      wait (full);
    count++;
    insert_item (item);
    if (count == 1)
      signal(empty);
  }
  Item remove(){                                    //从缓冲区中取出一个产品
    if (count == 0)
      wait (empty);
    count --;
    if (count == N-1)
      signal(full);
    return remove_item();
  }
end monitor;
producer (){                                        //生产者进程
    while(1){
      item=生产一个产品;
      ProdecerConsumer.insert (item);
  }
}
consumer (){                                        //消费者进程
  while(1){
    item = ProdecerConsumer.remove ();
    消费产品item;
  }
}

//死锁产生的必要条件：1.互斥条件；2.不剥夺条件；3.请求和保持条件；4.循环等待条件
//死锁处理策略
  //1.预防死锁
  //2.避免死锁
    //银行家算法
      /*安全序列：就是指如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是安全状态。
        当然，安全序列可能有多个。如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了不安全状态。这就意味着之
        后可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态，不过我们
        在分配资源之前总是要考虑到最坏的情况。*/

      /*如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，就可能发生死锁(处于不安全状态未必就是发生了死锁，
        但发生死锁时一定是在不安全状态)因此可以在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，以此决定是否答
        应资源分配请求。这也是“银行家算法”的核心思想。*/
int Max[5][3] = {7,5,3,3,2,2,9,0,2,2,2,2,4,3,3};            //五个进程对各种资源的最大需求
int Allocation[5][3] = {0,1,0,2,0,0,3,0,2,2,1,1,0,0,2};     //五个进程已分配的各种资源数目 
int Need[5][3] = {7,4,3,1,2,2,6,0,0,0,1,1,4,3,1};           //五个进程还需要各种资源的数目 
int Available[3] = {3,3,2};                                 //可利用的各资源的数目
int Work[3];                                                //可用资源数 
bool Finish[5];                                             //进程是否完成 
int Request[3];                                             //进程提出对各个资源请求的数目
int Sequence[5];                                            //安全序列
//安全性判断函数
bool is_safe(){                                             //安全性判断 
  int i,j,i1 = 0;
  bool t = false;
  for(i = 0; i < 3; i++){                                   //把Available赋值给Work
    Work[i] = Available[i];
  }
  for(i = 0; i<5; i++){                                     //初始化所有进程未完成
    Finish[i] = false;
  }
  while(1){
    for(j = 0; j < 5; j++){                                 //寻找Need小于等于Work的进程 
      if(Finish[j])
        continue;
      t = true;
      for(i = 0; i < 3; i++){
        if(Need[j][i] <= Work[i])
          continue;
        else{
          t = false;
          break;
        }
      }
      if(t) break;                                          //判断第j个进程是否满足Need小于等于Work
    }
    if(t && (Finish[j] == false)){                          //是否找到Need小于等于Work的进程并且进程未完成 
      for(i = 0; i < 3; i++){
        Work[i] = Work[i] + Allocation[j][i];
      }
      Finish[j] = true;                                     //进程完成 
      Sequence[i1] = j;                                     //安全序列
      i1++;
    }else{
      for(i = 0; i < 5; i++){
        if(Finish[i]) continue;
      else 
        return false;
      }
    return true;
    }
  }
return true;
} 
//资源请求函数
void request_option(int a){                         //资源的请求
  int i;
  bool t = true;
  for(i = 0; i < 3; i++){                           //判断Requesti是否小于等于Needi 
    if(Request[i] <= Need[a][i])
      continue;
    else{
      printf("错误！\n");                           //Requesti大于Needi出现错误，请求失败 
      t = false;
      break;
    }
  }
  if(t){
    for(i = 0; i < 3; i++){                        //判断Requesti是否小于等于Availablei
      if(Request[i] <= Need[a][i]) 
        continue;
      else{
        printf("错误，进程堵塞！\n");               //Requesti大于Availablei出现错误,进程Pi堵塞 
        t =  false;
        break;
       }
    }
 }
 if(t){                                            //试分配 
    for(i = 0; i < 3; i++){
      Available[i] = Available[i] - Request[i];
      Allocation[a][i] = Allocation[a][i] + Request[i];
      Need[a][i] = Need[a][i] - Request[i];
    }
  }
}
  //3.检测和解除：1.资源剥夺法；2.撤销进程法；3.进程回退法
  //死锁检测算法：在资源分配图中，依次消除与不阻塞进程相连的边，直到无边可消


//第三章  内存
  //如果计算机按字节编址，则一个存储单元的大小为1字节，即8位二进制数
  /*源代码文件经过编译生成目标模块（将高级语言翻译为二进制数），目标模块经过链接生成装入模块（链接后形成完整的逻辑地址），
    装入模块装入内存（形成物理地址）*/
  //三种链接方式
    //1.静态链接：装入前链接成一个完整的装入模块；
    //2.装入时动态链接：运行前边装入边链接；
    //3.运行时动态链接：运行时需要目标模块才装入并链接。
  //三种装入方式
    //1.绝对装入；编译时产生绝对地址；
    //2.可重定位装入（静态重定位）：装入时将逻辑地址转换为物理地址；
    //3.动态运行时装入（动态重定位）：运行时将逻辑地址准转换为物理地址，需设置重定位寄存器。

  //内存管理的功能
    //1.内存空间的分配与回收；
    //2.内存空间的扩充（虚拟性）；
    //3.地址转换（逻辑地址->物理地址）；
    //4.存储保护：1.设置上下限寄存器；2.设置重定位寄存器（基址寄存器）和界地址寄存器（限长寄存器）。

  //内存管理技术
    //覆盖技术：一个固定区（固定区中的程序段在运行过程中不会调入调出），若干覆盖区（覆盖区中的程序段在运行过程中会根据需要调入调出）
      //特别的，必须由程序员声明覆盖结构（对用户不透明），操作系统自动完成覆盖
    //交换技术：在内存紧张时，换出某些进程以腾出内存空间，再换入某些进程
      //特别的，磁盘会分为文件区和对换区，换出的进程放在对换区

  //内存管理方式
    //连续分配管理方式
      //1.单一连续分配：只支持单道程序，内存分为系统区和用户区，用户程序放在用户区（无外部碎片，有内部碎片）
      //2.固定分区分配：支持多道程序，内存的用户空间分为若干个固定大小的分区，每个分区只能装入一道作业（无外部碎片，有内部碎片）
      //3.动态分区分配：支持多道程序，在程序装入内存时，根据进程大小动态地建立分区（无内部碎片，有外部碎片；使用“紧凑”技术解决）
    //动态分区分配算法
      //首次适应算法(First Fit)
        //算法思想：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。
        //如何实现：空闲分区以地址递增的次序排列。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。
      //最佳适应算法(Best Fit)
        /*算法思想：由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连
          续的大片空间，可以尽可能多地留下大片的空闲区，即优先使用更小的空闲区。*/
        //如何实现：空闲分区按容量递增次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。
        //缺点：会产生很多难以利用的外部碎片。
      //最坏适应算法(Worst Fit)
        /*算法思想：为了解决最佳适应算法的问题——即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余
          的空闲区就不会太小，更方便使用。*/
        //如何实现：空闲分区按容量递减次序链接。每次分配内存时顺序查找空闲分区链(或空闲分区表)，找到大小能满足要求的第一个空闲分区。
        //缺点：大进程到来时会无处分配。
      //邻近适应算法(Next Fit)
        /*算法思想：首次适应算法每次都从链头开始查找，这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分
          区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。*/
        /*如何实现：空闲分区以地址递增的顺序排列(可排成一个循环链表)。每次分配内存时从上次查找结束的位置开始查找空闲分区链(或空闲分
          区表)，找到大小能满足要求的第一个空闲分区。*/

  //基本分页存储管理
    /*将内存空间分为一个个大小相等的分区(比如：每个分区4KB)，每个分区就是一个“页框”(页框=页帧=内存块=物理块=物理页面)。每个页框有
      一个编号，即“页框号”(页框号=页帧号=内存块号=物理块号=物理页号)，页框号从0开始。*/
    /*将进程的逻辑地址空间也分为与页框大小相等的一个个部分，每个部分称为一个“页”或“页面”。每个页面也有一个编号，即“页号”，页号也是
      从0开始。*/
    //操作系统以页框为单位为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的页面与内存的页框有一一对应的关系。
    //各个页面不必连续存放，可以放到不相邻的各个页框中。
    //页面在页框中的存储信息保存在进程PCB的页表（页表包括页号和块号）中，其中，页号隐藏不占用存储空间。
    //逻辑地址A对应的物理地址=P号页面在内存中的起始地址+页内偏移量W
    /*页号=逻辑地址/页面长度(取除法的整数部分)；页内偏移量=逻辑地址%页面长度(取除法的余数部分)
      逻辑地址对应的物理地址=页面在内存中存放的起始地址(内存块号*内存块大小)+页内偏移量*/
    //页表项的地址=页号*页表项大小+页表始址
    //结论：在32位系统中，如果页面大小为2^kB，则末尾k位为页内偏移量，32-k位为页号

  //基本地址变换机构
    /*基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。通常会在系统中设置一个页表寄存器(PTR)，存放页表在内存中的起始地址F
      和页表长度M。进程未执行时，页表的始址和页表长度放在进程控制块(PCB)中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。*/
    //页式管理中地址是一维的

  //具有快表的地址变换机构
    //快表，又称联想寄存器(TLB,translation lookaside buffer)，是一种访问速度比内存快很多的高速缓存(TLB不是内存!)，用来存放最近访
      问的页表项的副本，可以加速地址变换的速度。与此对应，内存中的页表常称为慢表。*/

  //两级页表（页目录表/外层页表/顶级页表）
    /*按照地址结构将逻辑地址拆分成三部分，从PCB中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置
      根据二级页号查表，找到最终想访问的内存块号结合页内偏移量得到物理地址*/
    //多级页表中，各级页表的大小不能超过一个页面。若两级页表不够，可以分更多级
    //多级页表的访存次数(假设没有快表机构)——N级页表访问一个逻辑地址需要N+1次访存

  //基本分段存储管理
    //进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段都有一个段名(在低级语言中，程序员使用段名来编程)，每段从0开始编址
    //内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。
    //段号的位数决定了每个进程最多可以分几个段；段内地址位数决定了每个段的最大长度是多少
    //程序分为多个段，每个段在内存中离散存放，为了在物理内存中找到各逻辑段的存放位置，需要给每个进程建立“段映射表”（段表）
    //每个段对应一个段表项，其中记录了该段在内存中的起始位置(又称“基址”)和段的长度。段表项长度相同，段号隐藏不占存储空间
    //分段的用户进程地址空间是二维的，程序员在标识一个地址时，既要给出段名，也要给出段内地址。

  //段页式管理方式
    //段号的位数决定了每个进程最多可以分几个段；页号位数决定了每个段最大有多少页；页内偏移量决定了页面大小、内存块大小是多少

  //虚拟内存
    //特征
      //多次性：无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
      //对换性：在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
      //虚拟性：从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。
  //请求分页管理方式
  //页面置换算法

//第四章  文件管理


//第五章  I/O设备
