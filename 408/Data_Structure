//顺序表
//特点：地址连续，依次存放，随机存取，类型相同
#define MAXSIZE 50
typedef struct{               //静态分配顺序表结构体定义  
   int data[MAXSIZE];         //定义存放数据的数组
   int length;                //数据指针
}SqList;                      //顺序表类型定义
//顺序表基本操作
bool InitSqList(SqList &L){   //顺序表初始化
   for(int i=0;i<MAXSIZE;i++) //数据域置0
      L.data[i]=0;
   L.length=0;                //表长为0
}
bool ListInsert(SqList &L,int i,int e){   //顺序表插入操作
   if(L.length>=Maxsize-1）               //判断顺序表是否存满
      return false;
   else if(i<1||i>L.length+1)             //判断插入的位序是否合法
      return false;
   for(int j=L.length;j>=i;j--)           //将位序在i之后的数组元素后移1位
      L.data[j]=L.data[j-1];
   L.data[i-1]=e;                         //将数据e的值赋值给数组下标为i-1的数组元素
   L.length++;                            //数据指针后移1位
   return true;
}
//代码段时间复杂度为O(n)
int ListDelete(SqList &L,int i,int &e){   //顺序表删除操作
   if(L.length<=0)                        //判断顺序表是否为空
      return 0;
   else if(i<1||i>L.length+1)             //判断删除的位序是否合法
      return 0;
   e=L.data[i-1];
   for(int j=i;j<L.length;j++)            //位序在i之后的元素前移1位
      L.data[j-1]=L.data[j];
   L.length--;                            //数据指针前移1位
   return e;
}
//代码段时间复杂度为O(n)
int LocateElem(SqList L,int e){           //顺序表按值查找
   for(int i=0;i<L.length;i++)
      if(L.data[i]==e)
         return i+1;                      //找到相同的值则返回其位序
}
//代码段时间复杂度为O(n)
int GetElem(SqList L,int i){              //顺序表按位序查找
   return L.data[i-1];                    //数组下标比位序少1
}
//代码段时间复杂度为O(1)

#define INITSIZE 10
typedef struct{               //动态分配顺序表结构体定义
   int *data;                 //指示动态分配的指针
   int length,maxsize;        //数组的当前长度和最大容量
}SqList;
bool InitList(SqList &L){                          //顺序表初始化
   L.data=(int *)malloc(INITSIZE*sizeof(int));     //分配INITSIZE个大小为int型的存储空间
   L.length=0;                                     //顺序表长度为0
   L.maxsize=INITSIZE;                             //顺序表最大能存储INITSIZE个数组数据
   return true;
}
bool IncreaseList(SqList &L,int len){              //增加顺序表的存储空间
   int *p=L.data;
   L.data=(int *)malloc((L.maxsize+len)*sizeof(int));
   for(int i=0;i<L.length;i++)
      L.data[i]=p[i];                              //把p指向的原来数据元素复制到新的空间
   L.maxsize+=len;
   free(p);
}
void PrintElem(SqList L){                          //打印顺序表的数据到屏幕
   for(int i=0;i<L.length;i++)
      printf("data[%d]=%d",i,L.data[i]);
}


//单链表
//特点：逻辑相邻的元素在物理位置上不相邻
typedef struct LNode{         //单链表结点结构体
   int data;                  //单链表数据域
   struct LNode *next;        //单链表指针域
}LNode,*LinkList;             //定义单链表结点类型
//单链表基本操作
bool InitList(LinkList &L){    //带头结点的单链表初始化
   L=(LNode *)malloc(sizeof(LNode));
   L->next=NULL;
   return true;
}
LinkList List_HeadInsert(LinkList &L){         //头插法建立单链表
   int x;
   scanf("%d",&x);
   while(x!='#'){
      LNode *s=(LNode *)malloc(sizeof(LNode));
      s->data=x;
      s->next=L->next;
      L->next=s;
      scanf("%d",&x);
   }
   return L;
}
//代码段时间复杂度为O(n)
LinkList List_TailInsert(Linklist &L){          //尾插法建立单链表
   int x;
   LNode *r=L->next;                            //增加一个尾指针r，使其始终指向单链表的尾结点
   scanf("%d",&x);
   while(x!='#'){
      LNode *s=(LNode *)malloc(sizeof(LNode));
      s->data=x;
      r->next=s;
      r=s;                                      //把新结点设置为新的尾结点
      scanf("%d",&x);
   }
   r->next=NULL;
   return L;
}
int GetElem(LinkList L,int i){       //按序号查找单链表结点的值
   LNode *p=L->next;
   int j=1;
   while(p&&j<i){
      p=p->next;
      j++;
   }
   return p->data;
}
//代码段时间复杂度为O(n)
LNode *LocateElem(LinkList L,int e){                //按值查找单链表结点
   LNode *p=L->next;
   while(p!=NULL&&p->data!=e)
      p=p->next;
   return p;
}
//代码段时间复杂度为O(n)
bool LNodeInsert(LinkList &L,int i,int e){          //单链表插入结点 
   if(i<1)
      return false;
   LNode *p=L->next;
   int j=1;
   while(p&&j<i-1){
      p=p->next;
      j++;
   }
   if(p==NULL)
      return false;
   LNode *s=(LNode *)malloc(sizeof(LNode));
   s->data=e;
   s->next=p->next;                                 //在第i-1位结点后插入新结点
   p->next=s;
   return true;
}
//代码段时间复杂度为O(n)
bool LNodeDelete(LinkList &L,int i,int &e){         //单链表删除结点
   if(i<1)
      return false;
   LNode *p=L->next;
   int j=1;
   while(p->next&&j<i-1){
      p=p->next;
      j++;
   }
   if(p==NULL)
      return false;
   LNode *q=p->next;
   p->next=q->next;
   free(q);
   return true;
}
//代码段时间复杂度为O(n)
int Length(LinkList L){          //求表长
   LNode *p=L->next;
   int i=1;
   while(P){
      i++;
      p=p->next;
   }
   return i;
}
//代码段时间复杂度为O(n)
bool DestoryList(LinkList &L){   //销毁单链表
   while(L->next){
      LNode *p=L->next;
      L->next=p->next;
      free(p);
   }
   free(L);
}

bool InitList(LinkList &L){     //不带头结点的单链表初始化
   L=NULL;
   return true;
}
bool LNodeInsert(LinkList &L;int i;int e){             //不带头结点的单链表的插入
   if(i<1)
      return false;
   if(i==1){
      LNode *s=(LNode *)malloc(sizeof(LNode));
      s->data=e;
      s->next=L;
      L=s;
      return true;
   }
   LNode *p=L;
   int j=1;
   while(p&&j<i-1){
      p=p->next;
      j++;
   }
   LNode *s=(LNode *)malloc(sizeof(LNode));
   s->data=e;
   s->next=p->next;                                 //在第i-1位结点后插入新结点
   p->next=s;
   return true;
}

//双链表
typedef struct DNode{                  //双链表结构体定义
   int data;                           //定义双链表数据域
   struct DNode *prior,*next;          //定义前向指针prior和后向指针next
}DNode,*DLinklist;                     //定义双链表名称
bool InitDLinkList(DLinkList &L){      //双链表初始化
   L=(DNode *)malloc(sizeof(DNode));
   L->prior=NULL;
   L->next=NULL;
   return true;
}
bool IsEmpty(DLinkList L){             //双链表判空
   if(L->next==NULL)
      return true;
   else
      return false;
}
bool DNodeInsert(DLinkList &L,int i,int e){    //双链表插入操作
   if(i<1)
      return false;
   DLinkList *p=L->next;
   int j=1;
   while(p&&j<=i-1){
      p=p->next;
      j++;
   }
   DLinkList *s=(DNode *)malloc(sizeof(DNode));
   s->data=e;
   s->next=p->next;
   if(p->next!=NULL)
      p->next->peior=s;
   s->prior=p;
   p->next=s;
   return true;
}
int DNodeDelete(DLinkList &L,int i,int &e){     //双链表删除操作
   if(i<1)                                      //位序i不合法
      return 0;
   DLinkList *p=L->next;
   int j=1;
   while(p->next&&j<=i-1){                     //找到第i-1位的双链表的结点
      p=p->next;
      j++;
   }
   DLinklist *q=p->next;
   e=q->data;
   p->next=q->next;
   if(q->next!=NULL)                          //判断去结点之后是否还有后继结点
      q->next->prior=p;
   free(q);
}
   
//循环单链表
typedef struct CNode{            //循环单链表结结点类型
   int data;
   struct CNode *next;
}CNode,*CLinkList;
bool InitCLinkList(CLinkList &L){   //循环单链表初始化
   L=(CNode *)malloc(sizeof(CNode));
   L->next=L;
   return true;
}
bool IsEmpty(CLinkList L){          //循环单链表判空
   return L->next==L;
}
bool IsTailCLinkList(CLinkList L,CNode *p){  //判断是否为表尾结点
   return p->next==L;
}

//循环双链表
typedef struct CDNode{          //循环双链表结点类型
   int data;
   struct CDNode *next,*prior;
}CDNode,*CDLinkList;
bool InitCDLinkList(CDLinkList &L){     //循环双链表初始化
   L=(CDNode *)malloc(sizeof(CDNode));
   L->next=L;
   L->prior=L;
   return true;
}
bool IsEmpty(CDLinkList L){             //双链表判空
 return L->next=L||L->prior=L;
}


//栈
//特点：先进后出（FILO）
/*先序序列为a，b，c，d的不同二叉树的个数、对n个不同元素进栈，出栈序列的个数、以及n个结点的二叉树有多少种不同形态等问题
都是卡特兰（Catalan）数1/(n+1)C_(n)2n*/
#define MAXSIZE 10
typedef struct{                        //定义顺序栈数据结构
   int data[MAXSIZE};                  //定义整型数组存放栈中的元素
   int top;                            //定义栈顶指针
}SqStack;
bool InitStack(SqStack &S){            //初始化顺序栈
   for(int i=0;i<MAXSIZE-1;i++)
      S.data[i]=0;
   S.top=-1;
   return true;
}
bool IsEmpty(SqStack S){               //判断栈空
   return S.top==-1;
}
bool push(SqStack &S,int e){           //顺序栈入栈操作
   if(S.top=MAXSIZE-1)
      return false;
   S.data[++S.top]=e;
}
int pop(SqStack &S,int &e){            //顺序栈出栈
   if(S.top=-1)
      return 0;
   e=S.data[S.top--];
}
int GetTop(SqStack S,int &e){          //获取栈顶元素
   return e=S.data[S.top];
}

//共享栈
# define MAXSIZE 10
typedef Struct{                        //定义共享栈数据结构
   int data[MAXSIZE];
   int top;
}ShareStack;
bool InitShareStack(ShareStack &S1.ShareStack &S2){   //共享栈初始化
   for(int i=0;i<MAXSIZE-1;i++)
      S1.data[i]=0;
   S1.top=-1;
   S2.top=MAXSIZE;
}
bool IsEmpty(ShareStack S1,ShareStack S2){           //共享栈判空
   return S1.top=-1&&S2.top=MAXSIZE;
}
bool IsFull(ShareStack S1,ShareStack S2){            // 判断栈满
   return S1.top+1==S2.top;
}


//队列
//特点：先进先出（FIFO）
#define MAXSIZE 10
typedef struct{                    //定义循环队列的数据类型
   int data[MAXSIZE];              //定义整型数组存放队列数据
   int front,rear;                 //定义队头指针和队尾指针
   int tag;                        //定义状态标志位判断Q.front==Q.rear时队列是否为空
}CirQueue;
bool InitCirStack(CirStack &Q){    //循环队列初始化
   Q.front=Q.rear=0;
   Q.tag=0;
}
bool IsEmpty(CirStack Q){          //循环队列判空
   return Q.front==Q.rear&&Q.tag=0;
}
bool EnQueue(CirStack &Q,int e){   //循环队列插入队尾元素
   if(Q.front==Q.rear&&Q.tag==1)
      return false;
   Q.data[Q.rear]=e;
   Q.rear=(Q.rear+1)%MAXSIZE;
   Q.tag=1;
   return true;
}
int DeQueue(CirStack &Q,int &e){   //循环队列输出队头元素
   if(Q.front==Q.rear&&Q.tag==0)
      return0;
   e=Q.data[Q.front];
   Q.front=(Q.front+1)%MAXSIZE;
   Q.tag=0;
   return e;
}
int LenQueue(CirStak &Q,int &l){    //当前循环队列的长度
   return l=(Q.rear+MAXSIZE-Q.front)%MAXSIZE;
}


//链栈
//操作基本与单链表相同
typedef struct StackNode{                       //定义链栈数据类型
   int data;
   struct StackNode *next;
}StackNode,*LinkStack;
bool InitLinkStack(LinkStack &ls){              //链栈初始化
   ls=(StackNode *)malloc(sizeof(StackNode));
   ls->next=NULL;
}
bool IsEmpty(LinkList ls){                      //链栈判空
   return ls->next==NULL;
}
bool StackInsert(LinkStack &ls,int e){          //链栈入栈
   StackNode *p=(StackNode *)malloc(sizeof(StackNode));
   p->data=e;                                   //头插法
   p->next=ls->next;
   ls->next=p;
}
int StackDelete(LinkStack &ls,int &e){         //链栈出栈
   StackNode *p=ls->next;
   e=p->data;
   ls->next=p->next;
   free(p);
}

//链队
typedef struct LinkNode{               //链式队列结点
   int data;
   struct LinkNode *next;
}LinkNode;
typedef struct{                       //链式队列
      LinkNode *front,*rear;          //指向链式队列队头和队尾的指针
}LinkQueue;
bool InitLinkQueue(LinkQueue &Q){                           //初始化链队列
   Q.front=Q.rear=(LinkNode *)malloc(sizeof(LinkNode));     //建立头结点
   Q.rear->next=NULL;
   return true;
}
bool IsEmpty(LinkQueue Q){                                  //链队列判空
   return Q.front==Q.rear==NULL;
}
bool DeLinkQueue(LinkQueue &Q){                             //销毁链队列
   while(Q.front){
      Q.rear=Q.front->next;
      free(Q.front);
      Q.front=Q.rear;
   }
   return true;
}
bool LinkQueueInsert(LinkQueue &Q,int e){                  //链队列队尾入队
   LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));
   s->data=e;
   s->next=Q.rear->next;
   Q.rear->next=s;
   Q.rear=Q.rear->next;
   return true;
}
int LinkNodeDe(LinkNode &Q,int &e){                        //链队列队头出队
   LinkNode *p=Q.front;
   Q->next=Q.front->next;
   Q.front=p->next;
   e=p->data;
   free(p);
}


//稀疏矩阵十字链表存储法
typedef struct OLNode{                 //十字链表法数据结构
   int i,j;                            //非零元素行和列下标
   int data;
   struct OLNode *right,*down;         //该非零元素所在的行表和列表的后继链域
}OLNode,*OLink；
bool InitOLNode(OLink &M){             //十字链表法初始化
   M=(OLNode *)malloc(sizeof(OLNode));
   M.i=5;
   M.j=5;                               //初始结点的行列下标分别存放矩阵的行数和列数
   M.data=6;                            //初始结点的数据域存放非零元素的个数
   M.right=NULL;
   M.down=NULL;
   return true;
}


//串
#define MAXSIZE 10
typedef struct{                         //定义串的数据结构
   char ch[MAXSIZE];                    //定义字符数组
   int length;                          //定义指针域
}SString;
bool InitStr(SString &S){               //串初始化
   for(int i=0;i<MAXSIZE;i++)
      S.ch[i]=0;
   S.length=0;
   return true;
}
bool StrCopy(SString &T,SString S){                     //串复制
   for(int i=0;i<S.length;i++){
      T.ch[i]=S.ch[i];
      T.legth++;
   }
return true;
}
bool IsEmpty(SString S){                                //串判空
   return S.length==0;
}
StrList StrCompare(SString S,SString T){                //串比较
   int i,j;
   for(i=0,j=0;i<S.length&&j<T.length;i++,j++){
      if(S.ch[i]>T.ch[i])
         return S;
      else if(S.ch[i]<T.ch[i])
         return T;
      else
         continue;
   }
   if(i>=S.length&&j>=T.length)
      return S==T;
   else
      return (S?T:S.length>T.length);
}
int StrLength(SString S){                                        //求串长
   return S.length;
}
StrList SubString(SString S,SString &T,int pos,int len){         //求子串
   if(pos<1||pos>S.length||len<0||len>S.length-pos)              //判断pos和len是否合法
      return 0;
   for(int i=pos-1;i<=len;i++)
      T.ch[j]=S.ch[i];
   T.length=len;
   return T;
}
StrList Concat(SString S1,SString S2,SString &T){                 //串连接
   for(int i=0;i<S1.length;i++)
      T.ch[i]=S1.ch[i];
   for(int i=0;i<S2.length;i++)
      T.ch[i+S1.length]=S2.ch[i];
   T.length=S1.length+S2.length;
   return T;
}

//简单模式匹配算法
int Index(SString S,SString T){                                   //串定位
   int i=1,j=1;                                                   //定义指向两个串的指针
   while(i<=S.length&&j<=T.length){                               //设置循环条件
      if(S.ch[i-1]==T.ch[i-1]){                                   //字符相等则继续比较
         ++i;
         ++j;
      }else{                                                      //否则重置指针位置
         i=i-j+2；                                                //i的位置为S的当前位置减去T串长度再后移1位
         j=1;                                                     //j指向T串首字符
      }
      if(j>T.length)                                              //j>T.length意为S中有子串与模式串匹配成功
         return i-T.length;
      else
         return 0;
}
//代码时间复杂度为O(mn)

//KMP算法
//思想：主串指针不动而让子串的指针移动到可以继续匹配的字符位置
//例如模式串为abaabc，则next数组为next[1]=0，next[2]=1，next[3]=1，next[4]=2，next[5]=2，next[6]=3，算法如下
int Index_KMP(SString S,SString T,int next[]){                    //使用KMP算法进行串定位
   int i=1,j=1;
   while(i<=S.length&&j<=T.length){
      if(j=0||S.ch[i-1]==T.ch[j-1]){                              //配合数组next[1]，即第一个字符不匹配的情况
         ++i;
         ++j;
      }else{
         j=next[j];
      }
      if(j>T.length)
         return i-T.length;
      else
         return 0;
}
//代码时间复杂度为O(m+n)
//优化KMP算法
/*思想：如果匹配失败的字符和next数组中待匹配的字符相同，则该次匹配一定失败，可使模式串指针继续向前回溯。
因此，可使用优化的nextval数组代替next数组*/
/*例如模式串abaabc中，当第三个字符a不匹配时next数组会使模式串指针移动到第一个a字符位置，已知该处不是字
符a则此次移动必然不匹配，需再次移动指针到0的位置。所以，优化后的nextval[3]=0*/
//优化后的nextval数组为nextval[1]=0，nextval[2]=1，nextval[3]=0，nextval[4]=2，nextval[5]=1，nextval[6]=3
//求nextval数组的算法
nextval[1]=0;
for(int j=2;j<=T.length;j++){
   if(T.ch[next[j]]==T.ch[j])
      nextval[j]=nextval[next[j]];
   else
      netval[j]=next[j];
}


//树
//性质：1.结点数=总度数+1 2.度为m的树（或m叉树）第i层至多有m^(i-1)个结点 3.高度为h的m叉树至多有(m^h-1)/(m-1)个结点
// 4.高度为h的m叉树至少有h个结点 5.高度为h，度为m的树至少有h+m-1个结点 6.具有n个结点的m叉树的最小高度为⌈log_m(n(m-1)+1)⌉

//二叉树
/*性质：1.设非空二叉树中度为0，1，2的节点个数分别为n_0，n_1，n_2，则n_0=n_2+1。2.二叉树的第i层至多有2^(i-1)个结点。
3.高度为h的二叉树至多有2^h-1个结点。*/

//满二叉树：一颗高度为h，且含有2^h-1个结点的二叉树
//特点：1.只有最后一层有叶子结点。2.不存在度为1的结点。3.按层序从1开始编号，结点i的左孩子为2i、右孩子为2i+1、父结点为⌊i/2⌋

//完全二叉树：当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树
//特点：1.只有最后两层有叶子结点。2.最多只有1个度为1的结点。3.i<=⌊n/2⌋为分支结点，i>⌊n/2⌋为叶子结点（n为完全二叉树中结点个数）
/*性质：1.具有n(n>0)个结点的完全二叉树的高度h为⌈log_2(n+1)⌉或⌊log_2(n)⌋+1。2.对于完全二叉树，可以由结点数n推出度为0、1和2的
结点个数为n_0、n_1和n_2，完全二叉树最多只有一个度为1的结点，即n_1=0或1；n_0+n_2一定是奇数。若完全二叉树有2k（偶数）个结点，
则必有n_1=1,n_0=k，n_2=k-1；若完全二叉树有2k+1（奇数）个结点，则必有n_1=0,n_0=k，n_2=k-1。*/

//二叉排序树：左子树结点编号均小于根结点，右子树结点编号均大于根结点，左子树和右子树友个是一棵二叉排序树

//平衡二叉树：任意结点的左子树和右子树高度只差不超过1（平衡因子）

//二叉树的链式存储
typedef struct BiTNode{                    //定义存储二叉树的数据类型
   int data;
   struct BiTNode *lchild,*rchild;         //定义指向左右孩子的指针
}BiTNode,* BiTree;
bool InitBiTree(BiTree &T){                //树结点的初始化
   T=(BiTNode *)malloc(sizeof(BiTNode));
   T->lchild=NULL;
   T->rchild=NULL;
   return true;
}                                           //n个结点的二叉链表共有n+1个空链域
void PreOrder(BiTree T){                    //二叉树的先序遍历（根左右）
   if(T!=NULL){
      visit(T);
      PreOrder(T->lchild);
      PreOrder(T->rchild);
   }
}
void InOrder(BiTree T){                     //二叉树中序遍历（左根右）
   if(T!=NULL){
      InOrder(T->lchild);
      visit(T);
      InOrder(T->rchild);
   }
}
void PostOrder(BiTree T){                   //二叉树后序遍历（左右根）
   if(T!=NULL){
      PostOrder(T->lchild);
      PostOrder(T->rchild);
      visit(T);
   }
}
//代码时间复杂度为O(h)，其中h为二叉树的高度
void LevelOrder(BiTree T){                   //二叉树的层序遍历
   LinkQueue Q;                              //定义一个链队列
   InitLinkQueue(Q);                         //初始化链队列
   EnLinkQueue(Q,T);                         //二叉树根结点入队
   BiTree p;
   while(!IsEmpty(Q)){                       //队列非空
      DeLinkQueue(Q,p);                      //队头元素出队
      visit(p);                              //访问出队元素
      if(p-lchild)
         EnLinkQueue(Q,p->lchild);           //左孩子非空则左孩子入队
      if(p->rchild)
         EnLinkQueue(Q,p->rchild);           //右孩子非空则右孩子入队
   }
}
//由遍历序列构造二叉树主要要确定根结点，再根据中序遍历序列划分左右子树

//线索二叉树
//当二叉树按照先序、中序、后序序列排列后，其中任意一个元素有且只有一个前驱和后继结点，可以利用叶子结点的(n+1)个空链域使二叉树线索化
typedef struct ThreadNode{               //定义线索二叉树的数据类型
   int data;
   struct ThreadNode *lchild,* rchild;
   int ltag,rtag;                        //定义左右孩子的标志位，ltag==0为孩子，ltag==1为前驱；rtag==0为孩子，rtag==1为后继
}ThreadNode,* ThreadTree;
//中序线索二叉树
ThreadNode *pre=NULL;                    //定义指向访问当前结点的前驱的结点，初始指向NULL（pre是全局变量，否则需要加"&"）
void CreateInThread(ThreadTree T){       //中序线索化二叉树T
   if(T!=NULL)
      InThread(T);
   if(pre->rchild==NULL)                 //中序遍历完成后pre指向最后一个结点，需要单独进行处理
      pre->rtag=1;                       //pre的rtag置1，线索化完成
}
void InThread(ThreadTree T){             //中序遍历二叉树
   InThread(T->lchild);
   visit(T);
   InThread(T->rchild);
}
void visit(ThreadNode *q){                //在visit函数中对二叉树行中序线索化
   if(q->lchild==NULL){                   //pre结点是q结点的前驱，q的lchild指向中序前驱结点
      q->lchild=pre;
      q->ltag=1;
   }
   if(pre!=NULL&&pre->rchild==NULL){      //q结点是pre结点的后继，pre的rchild指向中序后继结点
      pre->rchild=q;
      pre->rtag=1;
   }
   pre=q;
}
//先序线索二叉树
ThreadNode *pre=NULL;                     //定义指向访问当前结点的前驱的结点，初始指向NULL（pre是全局变量，否则需要加"&"）
void CreatePreThread(ThreadTree T){       //先序线索化二叉树T
   if(T!=NULL)
      PreThread(T);
   if(pre->rchild==NULL)                  //先序遍历完成后pre指向最后一个结点，需要单独进行处理
      pre->rtag=1;                        //pre的rtag置1，线索化完成
}
void PreThread(ThreadTree T){             //先序遍历二叉树
   visit(T);
   if(T->ltag==0)                         //lchild不是前驱结点
      PreThread(T->lchild);
   PreThread(T->rchild);
}
void visit(ThreadNode *q){                //在visit函数中对二叉树行先序线索化
   if(q->lchild==NULL){                   //pre结点是q结点的前驱，q的lchild指向中序前驱结点
      q->lchild=pre;
      q->ltag=1;
   }
   if(pre!=NULL&&pre->rchild==NULL){      //q结点是pre结点的后继，pre的rchild指向中序后继结点
      pre->rchild=q;
      pre->rtag=1;
   }
   pre=q;
}
//后序线索二叉树
ThreadNode *pre=NULL;                     //定义指向访问当前结点的前驱的结点，初始指向NULL（pre是全局变量，否则需要加"&"）
void CreatePostThread(ThreadTree T){      //后序线索化二叉树T
   if(T!=NULL)
      PostThread(T);
   if(pre->rchild==NULL)                  //后序遍历完成后pre指向最后一个结点，需要单独进行处理
      pre->rtag=1;                        //pre的rtag置1，线索化完成
}
void PostThread(ThreadTree T){            //后序遍历二叉树
   PostThread(T->lchild);
   PostThread(T->rchild);
   visit(T);
}
void visit(ThreadNode *q){                //在visit函数中对二叉树行后序线索化
   if(q->lchild==NULL){                   //pre结点是q结点的前驱，q的lchild指向中序前驱结点
      q->lchild=pre;
      q->ltag=1;
   }
   if(pre!=NULL&&pre->rchild==NULL){      //q结点是pre结点的后继，pre的rchild指向中序后继结点
      pre->rchild=q;
      pre->rtag=1;
   }
   pre=q;
}

//中序线索二叉树中找中序后继
ThreadNode *FirstNode(ThreadNode *p){      //找到以p为根的子树中，第一个被中序遍历的结点（为p的右子树中的最左下的孩子）
   while(p->ltag==0)                       //当p的左子树非空，则循环遍历它的左孩子
      p=p->lchild;
   return p;
}
ThreadNode *NextNode(ThreadNode *p){       //在中序线索二叉树中找到结点p的后继结点
   if(p->rtag==0)
      return FirstNode(p->rchild);
   else
      return p->rchild;                    //rtag==1直接返回后继节点
}
void InOrder(ThreadNode *T){               //对中序线索二叉树进行中序遍历（利用线索实现非递归算法）
   for(ThreadNode *p=FirstNode(T);p!=NULL;p=NextNode(p))
      visit(p);
}
//代码时间复杂度为O(1)
//中序线索二叉树中找中序前驱
ThreadNode *LastNode(ThreadNode *p){         //找到以p为根的子树中，最后一个被中序遍历的结点（为p的左子树中的最右下的孩子）
   while(p->rtag==0)                         //当p的右子树非空。则循环遍历它的右孩子
      p=p->rchild;
   return p;
}
ThreadNode *PreNode(ThreadNode *p){          //在中序线索二叉树中找到结点p的前驱结点
   if(p->ltag==0)
      return LastNode(p->lchild);
   else
      return p->lchild;
}
void RevInOrder(ThreadNode *T){              //对中序线索二叉树进行逆中序遍历
   for(ThreadNode *p=LastNode(T);p!=NULL;p=PreNode(p))
      visit(p);
}
//先序线索二叉树中找先序后继
ThreadNode *NextNode(ThreadNode *p){      //以p为根结点的子树中的后继结点为p的左孩子；如果p->lchild==NULL，则为右孩子
   if(p->lchild!=NULL)
      return p->lchild;
   else
      return p->rchild;
}
//后序线索二叉树中找后序前驱
ThreadNode *PreNode(ThreadNode *p){       //以p为根结点的子树中的前驱结点为p的右孩子；如果p->lchild==NULL，则为左孩子
   if(p->rchild!=NULL)
      return p->rchild;
   else
      return p->lchild;
}

//树的顺序存储（双亲表示法）
#define MAx_TREE_SIZE 100
typedef struct{                           //树的结点定义
   int data;                              //数据元素
   int parent;                            //双亲位置域
}PTNode;
typedef struct{                           //双亲表示法的数据类型
   PTNode nodes[MAX_TREE_SIZE];           //定义PTNode结构体类型数组变量
   int n;                                 //结点数
}PTree;
//特点：找双亲结点方便，找孩子结点需要遍历整个数组。例如：并查集
//树的顺序+链式存储（孩子表示法）
struct CTNode{                            //定义链表元素
   int child;                             //孩子结点在数组中的位置
   struct CTNode *next;                   //指向下一个孩子的指针
};
typedef struct{                           //定义包含data和链表的数组元素
   int data;
   struct CTNode *firstchild;             //第一个孩子
}CTBox;
typedef struct{                           //定义数组元素
   CTBox nodes[MAX_TREESIZE];
   int n,r;                               //结点数和根结点的位置
}CTree;
//特点：找孩子节点方便，找双亲结点需要遍历整个数组链表。例如：服务流程树
//树的链式存储（孩子兄弟表示法）
typedef struct CSNode{
   int data;
   struct CSNode *firstchild, *nextsibling;     //定义结点的第一个孩子和右兄弟指针
}CSNode,* CSTree;
//特点：既可以存储树，也可以存储森林

//树的遍历
//先根遍历：先访问根结点，再依次访问根结点每棵子树，其遍历序列与树相应二叉树的先序序列相同
//后根遍历：先依次访问根结点每棵子树，再访问根结点，其遍历序列与树相应二叉树的中序序列相同
//层序遍历：自上而下、自左至右访问树中每个结点，即树的广度优先遍历(BFS)

//森林的遍历
//先序遍历森林：依次对森林中的各树进行先根遍历；或将森林转化成对应的二叉树后，对二叉树进行先序遍历
//中序遍历森林：依次对森林中的各树进行后根遍历；或将森林转化成对应的二叉树后，对二叉树进行中序遍历

//树与二叉树的应用
//哈夫曼树
//结点的权：具有某种现实含义的数值
//结点的带权路径长度：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积
//树的带权路径长度：树中所有叶结点的带权路径长度之和
//在含有n个带权叶结点的二叉树中，其中带权路径长度(WPL)最小的二叉树称为哈夫曼树，也称最优二叉树
/*特点：1.每个初始结点最终都成为叶子结点，且权值越小的结点到根结点的路径长度越大。2.哈夫曼树的结点总数为2n-1（n个结点会产生n-1个
分支结点）。3.哈夫曼树中不存在度为1的结点。4.哈夫曼树不唯一，但WPL必然相同且为最优。*/
//哈夫曼编码：将字符频次作为字符权结点权值，构造哈夫曼树，即可得到哈夫曼编码，可用于数据压缩

//并查集(Disjoint Set)
#define MAXSIZE 10
int UFSets[MAXSIZE];         //集合元素数组
void Initial(int s[]){       //初始化并查集
   for(int i=0;i<MAXSIZE;i++)
      s[i]=-1;
}
int Find(int s[],int x){     //Find查操作，找到x所属的集合
   while(s[x]>=0)           //循环寻找x的根
      x=s[x];
   return x;
}
//此代码时间复杂度为O(n)
void Union(int s[],int root1,int root2){    //Union并操作，将两个集合合并为一个
   if(root1==root2)                         //root1和root2属于不同的集合
      return;
   s[root2]=root1;                          //将根root2连接到root1下面
}
//此代码时间复杂度为O(1)
//Union并操作优化
//思想：将根结点的-1更改为-结点总数，可以方便判断树的大小，将小树合并到大树下面可以避免树过高
void Union(int s[],int root1,int root2){    //Union并操作，将两个集合合并为一个
   if(root1==root2)
      return;
   if(s[root2]>s[root1]){                   //root2结点数更少（负数比大小）
      s[root1]+=s[root2];                   //累加结点总数
      s[root2]=root1;                       //小树合并到大树
   }else{
      s[root2]+=s[root1];
      s[root1]=root2;
   }
}
//优化后树的高度不超过⌊log_2(n)⌋+1，在执行Find操作时时间复杂度为O(log_2(n))
//Find查操作优化
//思想：一个结点通过不断循环找到根结点后会形成一条路径，将路径上的各结点都连接到根结点下，可以减少循环次数
int Find(s[],int x){              //Find操作，找到x所属的集合
   int root=x;
   while(s[root]>=0)
      root=s[root];               //循环找到根
   while(x!=root){                //压缩路径
      int temp=s[x];              //定义临时指针只想父结点，避免路经丢失
      s[x]=root;                  //将x连接到根结点下面
      x=temp;
   }
   return root;
}


//图
//图G由顶点集V和边集E组成，记为G=(v,E),V(G)表示图G中顶点的有限非空集；E(G)表示图G中顶点之间的关系（边）集合
//若E是无向边（简称边）的有限集合时，则图G为无向图。对于无向图，顶点v的度是指依附于该顶点的边的条数，记为TD(v)
/*若E是有向边（简称弧）的有限集合时，则图G为有向图。对于有向图，入度是以顶点v为终点的有向边的数目，记为ID(v)；
出度是以顶点v为起点的有向边的数目，记为OD(v)。顶点v的度等于其入度和出度之和，即TD(v)=ID(v)+OD(v)*/
/*在无向图中，若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。
性质：对n个结点的无向图G，若G是连通图，则最少有n-1条边（否则一定有回路）；若G是非连通图，则最多可能有C_(n-1)2条边*/
/*在有向图中，若图G中任何一对顶点都是强连通的，则称此图为强连通图
性质：对n个顶点的有向图G，若G是强连通图，则最少有n条边（形成回路）*/
//无向图中的极大连通子图（包含尽可能多的顶点和边）称为连通分量；有向图中极大强连通子图称为称为有向图的强连通分量
//连通图的生成树是包含图中全部顶点的一个极小连通子图，若图中顶点数为n，则它的生成树含有n-1条边
//在非连通图中，连通分量的生成树构成了非连通图的生成森林。
//边的权：在一个图中，每条边都可以标上具有某种含义的数值，该数值称为该边的权值。
//带权图/网：边上带有权值的图称为带权图，也称网。
//带权路径长度：当图是带权图时，一条路径上所有边的权值之和，称为该路径的带权路径长度
//无向完全图共有C_n(2)条边，有向完全图共有2C_(n)2条边

//图的存储
//邻接矩阵
#define MAX_VERTEX_NUM 100                          //顶点数目最大值
typedef struct{
   char Vex [MAX_VERTEX_NUM];                       //一维数组存放顶点表
   int Edge [MAX_VERTEX_NUM] [MAX_VERTEX_NUM];      //二维数组存放邻接矩阵，即边表
   int vexnum, arcnum;                              //图的当前顶点数和边数（弧数）
} MGraph;
//代码空间复杂度为O(|V|^2)，因此适合存储稠密图（表示方法唯一）

//邻接表（类似树的“孩子表示法”）
#define MAX_VERTEX_NUM 100
typedef struct EdgeNode{                        //边表结点
   int adjvex;                                  //邻接点域，存储该顶点对应的下标
   int weight;                                  //用于存储权值，对于非网图可以不需要
   struct EdgeNode *next;                       //链域，指向下一个邻接点
}EdgeNode;
typedef struct VertexNode{                      //定义顶点数据类型
   char data;                                   //顶点域，存放顶点的数据
   EdgeNode *firstedge;                         //第一条边或弧
}VertexNode,AdjList[MAX_VERTEX_NUM];
typedef struct{                                 //定义邻接表的数据类型
   AdjList vertices;
   int vexnum,arcnum;
}ALGraph;
//存储无向图的空间复杂度为O(|V|+2|E|)，存储有向图的空间复杂度为O(|V|+|E|)（表示方法不唯一）

//十字链表（有向图）
#define  MAX_VERTEX_NUM 100        //图中顶点的最大数量
#define  InfoType int*             //表示弧额外信息的数据类型
#define  VertexType char           //图中顶点的数据类型
//表示链表中存储弧的结点
typedef struct ArcNode {
    int tailvex, headvex;           //弧尾、弧头对应顶点在顺序表中的位置下标
    struct ArcNode* hlik, * tlink;  //hlik指向下一个以当前顶点为弧头的弧结点；
                                    //tlink 指向下一个以当前顶点为弧尾的弧结点；
    //InfoType info;                //存储弧相关信息的指针
}ArcNode;
//表示顺序表中的各个顶点
typedef struct VexNode {
    VertexType data;                 //顶点的数据域
    ArcNode* firstin, * firstout;    //指向以该顶点为弧头和弧尾的链表首个结点
}VexNode;
//表示十字链表存储结构
typedef struct {
    VexNode xlist[MAX_VERTEX_NUM];   //存储顶点的顺序表
    int vexnum, arcnum;              //记录图的顶点数和弧数
}OLGraph;
//代码空间复杂度为O(|v|+|E|)（表示方法不唯一）

//邻接多重表（无向图）
#define MAX_VERTEX_NUM 100                     //图中顶点的最大数量
#define InfoType int*                          //边结点中info域的数据类型
#define VertexType int                         //顶点的数据类型
typedef enum { unvisited, visited }VisitIf;    //边标志域
//表示链表中的各个结点
typedef struct EBox {
    VisitIf mark;                            //标志域
    int ivex, jvex;                          //边两边顶点在顺序表中的位置下标
    struct EBox* ilink, * jlink;             //分别指向与ivex、jvex相关的下一个边结点
    InfoType* info;                          //边的其它信息，如权值
}EBox;
//存储图中的各个顶点
typedef struct VexBox {
    VertexType data;                        //顶点数据域
    EBox* firstedge;                        //指向当前顶点对应的链表
}VexBox;
//表示邻接多重表结构
typedef struct {
    VexBox adjmulist[MAX_VERTEX_NUM]; //存储图中顶点的顺序表
    int vexnum, edgenum;              //记录图中的顶点数量和边数量
}AMLGraph;
//代码空间复杂度为O(|V|+|E|)（表示方法不唯一）

//图的广度优先遍历(BFS)
bool visited [MAX_VERTEX_NUM];                                //访问标记数组
void BFSTraverse(Graph G){                                    //对图G进行广度优先遍历
   for(int i=0;i<G.vexnum;++i)
      visited[i]=false;                                       //初始化访问标记数组
   InitQueue(Q);                                              //初始化辅助队列Q
   for(int i=0;i<G.vexnum;++i){                               //从0号顶点开始遍历
      if(!visited[i])                                         //V(i)结点未访问过，从V(i)开始BFS
         BFS(G,i);
   }
}
void BFS(Graph G,int v){                                      //从顶点v出发，广度优先遍历图G
   visit(v);                                                  //访问初始顶点v
   visited[v]=true;                                           //对v做已访问标记
   Enqueue(Q,v);                                              //顶点v入队列Q
   while(!isEmpty(Q) ){
      DeQueue(Q,v);                                           //顶点v出队列
      for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){   //检测v所有邻接点
         if(!visited[w] ){                                    //w为v的尚未访问的邻接顶点
            visit(w);                                         //访问顶点W
            visited[w]=TRUE;                                  //对w做已访问标记
            EnQueue(Q,w);                                     //顶点w入队列
         }
      }
   }
}
//对邻接矩阵来说，进行BFS的时间复杂度为O(|V|^2)；对邻接表来说，进行BFS的时间复杂度为O(|V|+|E|)。空间复杂度为O(|V|)

//图的深度优先遍历(DFS)
bool visited[MAX_VERTEX_NUM];                                 //访问标记数组
void DFSTraverse(Graph G){                                    //对图G进行深度优先遍历
   for(v=0;v<G.vexnum;++v)
      visited[v]=false;                                       //初始化访问标记数组
   for(v=0;v<G.vexnum;++v){                                   //从0号顶点开始遍历
      if(!visited[v])
         DFS(G,v);
   }
}
void DFS(Graph G,int v){                                      //从顶点v出发，深度优先遍历图G
   visit(v);                                                  //访问顶点v
   visited[v]=true;                                           //修改访问标记
   for(w=FirstNeighbor(G,v);i>=0;w=NextNeighbor(G,v,w)){
      if(!visited[w])                                         //w为尚未访问的邻接顶点
         DFS(G,w);
   }
}
//对邻接矩阵来说，进行DFS的时间复杂度为O(|V|^2)；对邻接表来说，进行DFS的时间复杂度为O(|V|+|E|)。空间复杂度为O(|V|)

//图的最小生成树(Minimum-Spanning-Tree,MST)
//连通图的生成树是包含图中全部顶点的一个极小连通子图
//性质：1.如果一个连通图本身就是一棵树，则其最小生成树就是它本身。2.只有连通图才有生成树，非连通图只有生成森林。
//Prim（普里姆）算法
//思想：从某一个顶点开始构建生成树；每次将代价最小的新顶点纳入生成树，直到所有顶点都纳入为止
//算法时间复杂度为O(|v|^2)
//Kruskal（克鲁斯卡尔）算法
//思想：每次选择一条权值最小的边，使这条边的两头连通（原本已经连通的就不选）直到所有结点都连通
//算法时间复杂度为O(Elog_2(E))

//单源最短路径问题_BFS算法（无权图）
#define INFINITE 2147483647
void BFS_MIN_Distance(Graph G,int v){                      //求顶点v到其他顶点的最短路径
   for(int i=0;i<G.vexnum;++i){
      d[i]=INFINITE;                                       //d[i]表示v到i结点的最短路径
      path[i]=-1;                                          //最短路径从哪个顶点过来
   }
   d[v]=0;
   visited[v]=true;
   EnQueue(Q,v);
   while(!IsEmpty(Q)){                                     //BFS算法主要过程
      DeQueue(Q,v);
      for(w=FirstNeighbor(G,v);w>=0;w=NextNeighbor(G,v,w)){   //w为v的尚未访问的邻接顶点
         if(!visited(w)){
            d[w]=d[v]+1;                                      //w的路径长度加1
            path[w]=v;                                        //最短路径从v到w
            visited[w]=true;                                  //设置访问标志
            EnQueue(Q,w);                                     //顶点w入栈
         }
      }
   }
}
//单源最短路径问题_Dijkstra算法（无权图、带权图）

//各顶点间的最短路径问题_Floyd算法（无权图、带权图）
