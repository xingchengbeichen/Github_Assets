//顺序表
//特点：地址连续，依次存放，随机存取，类型相同
#define MAXSIZE 50
typedef struct{               //静态分配顺序表结构体定义  
   int data[MAXSIZE];         //定义存放数据的数组
   int length;                //数据指针
}SqList;                      //顺序表类型定义
//顺序表基本操作
bool InitSqList(SqList &L){   //顺序表初始化
   for(int i=0;i<MAXSIZE;i++) //数据域置0
      L.data[i]=0;
   L.length=0;                //表长为0
}
bool ListInsert(SqList &L,int i,int e){   //顺序表插入操作
   if(L.length>=Maxsize-1）               //判断顺序表是否存满
      return false;
   else if(i<1||i>L.length+1)             //判断插入的位序是否合法
      return false;
   for(int j=L.length;j>=i;j--)           //将位序在i之后的数组元素后移1位
      L.data[j]=L.data[j-1];
   L.data[i-1]=e;                         //将数据e的值赋值给数组下标为i-1的数组元素
   L.length++;                            //数据指针后移1位
   return true;
}
//代码段时间复杂度为O(n)
int ListDelete(SqList &L,int i,int &e){   //顺序表删除操作
   if(L.length<=0)                        //判断顺序表是否为空
      return 0;
   else if(i<1||i>L.length+1)             //判断删除的位序是否合法
      return 0;
   e=L.data[i-1];
   for(int j=i;j<L.length;j++)            //位序在i之后的元素前移1位
      L.data[j-1]=L.data[j];
   L.length--;                            //数据指针前移1位
   return e;
}
//代码段时间复杂度为O(n)
int LocateElem(SqList L,int e){           //顺序表按值查找
   for(int i=0;i<L.length;i++)
      if(L.data[i]==e)
         return i+1;                      //找到相同的值则返回其位序
}
//代码段时间复杂度为O(n)
int GetElem(SqList L,int i){              //顺序表按位序查找
   return L.data[i-1];                    //数组下标比位序少1
}
//代码段时间复杂度为O(1)

#define INITSIZE 10
typedef struct{               //动态分配顺序表结构体定义
   int *data;                 //指示动态分配的指针
   int length,maxsize;        //数组的当前长度和最大容量
}SqList;
bool InitList(SqList &L){                          //顺序表初始化
   L.data=(int *)malloc(INITSIZE*sizeof(int));     //分配INITSIZE个大小为int型的存储空间
   L.length=0;                                     //顺序表长度为0
   L.maxsize=INITSIZE;                             //顺序表最大能存储INITSIZE个数组数据
   return true;
}
bool IncreaseList(SqList &L,int len){              //增加顺序表的存储空间
   int *p=L.data;
   L.data=(int *)malloc((L.maxsize+len)*sizeof(int));
   for(int i=0;i<L.length;i++)
      L.data[i]=p[i];                              //把p指向的原来数据元素复制到新的空间
   L.maxsize+=len;
   free(p);
}
void PrintElem(SqList L){                          //打印顺序表的数据到屏幕
   for(int i=0;i<L.length;i++)
      printf("data[%d]=%d",i,L.data[i]);
}


//单链表
//特点：逻辑相邻的元素在物理位置上不相邻
typedef struct LNode{         //单链表结点结构体
   int data;                  //单链表数据域
   struct LNode *next;        //单链表指针域
}LNode,*LinkList;             //定义单链表结点类型
//单链表基本操作
bool InitList(LinkList &L){    //带头结点的单链表初始化
   L=(LNode *)malloc(sizeof(LNode));
   L->next=NULL;
   return true;
}
LinkList List_HeadInsert(LinkList &L){         //头插法建立单链表
   int x;
   scanf("%d",&x);
   while(x!='#'){
      LNode *s=(LNode *)malloc(sizeof(LNode));
      s->data=x;
      s->next=L->next;
      L->next=s;
      scanf("%d",&x);
   }
   return L;
}
//代码段时间复杂度为O(n)
LinkList List_TailInsert(Linklist &L){          //尾插法建立单链表
   int x;
   LNode *r=L->next;                            //增加一个尾指针r，使其始终指向单链表的尾结点
   scanf("%d",&x);
   while(x!='#'){
      LNode *s=(LNode *)malloc(sizeof(LNode));
      s->data=x;
      r->next=s;
      r=s;                                      //把新结点设置为新的尾结点
      scanf("%d",&x);
   }
   r->next=NULL;
   return L;
}
int GetElem(LinkList L,int i){       //按序号查找单链表结点的值
   LNode *p=L->next;
   int j=1;
   while(p&&j<i){
      p=p->next;
      j++;
   }
   return p->data;
}
//代码段时间复杂度为O(n)
LNode *LocateElem(LinkList L,int e){   //按值查找单链表结点
   LNode *p=L->next;
   while(p!=NULL&&p->data!=e)
      p=p->next;
   return p;
}
//代码段时间复杂度为O(n)
bool LNodeInsert(LinkList &L,int i,int e){          //单链表插入结点 
   if(i<1)
      return false;
   LNode *p=L->next;
   int j=1;
   while(p&&j<i-1){
      p=p->next;
      j++;
   }
   if(p==NULL)
      return false;
   LNode *s=(LNode *)malloc(sizeof(LNode));
   s->data=e;
   s->next=p->next;                                 //在第i-1位结点后插入新结点
   p->next=s;
   return true;
}
//代码段时间复杂度为O(n)
bool LNodeDelete(LinkList &L,int i,int &e){         //单链表删除结点
   if(i<1)
      return false;
   LNode *p=L->next;
   int j=1;
   while(p->next&&j<i-1){
      p=p->next;
      j++;
   }
   if(p==NULL)
      return false;
   LNode *q=p->next;
   p->next=q->next;
   free(q);
   return true;
}
//代码段时间复杂度为O(n)
int Length(LinkList L){         //求表长
   LNode *p=L->next;
   int i=1;
   while(P){
      i++;
      p=p->next;
   }
   return i;
}
//代码段时间复杂度为O(n)
bool DestoryList(LinkList &L){   //销毁单链表
   while(L->next){
      LNode *p=L->next;
      L->next=p->next;
      free(p);
   }
   free(L);
}

bool InitList(LinkList &L){     //不带头结点的单链表初始化
   L=NULL;
   return true;
}
bool LNodeInsert(LinkList &L;int i;int e){             //不带头结点的单链表的插入
   if(i<1)
      return false;
   if(i==1){
      LNode *s=(LNode *)malloc(sizeof(LNode));
      s->data=e;
      s->next=L;
      L=s;
      return true;
   }
   LNode *p=L;
   int j=1;
   while(p&&j<i-1){
      p=p->next;
      j++;
   }
   LNode *s=(LNode *)malloc(sizeof(LNode));
   s->data=e;
   s->next=p->next;                                 //在第i-1位结点后插入新结点
   p->next=s;
   return true;
}

//双链表
typedef struct DNode{                  //双链表结构体定义
   int data;                           //定义双链表数据域
   struct DNode *prior,*next;          //定义前向指针prior和后向指针next
}DNode,*DLinklist;                     //定义双链表名称
bool InitDLinkList(DLinkList &L){      //双链表初始化
   L=(DNode *)malloc(sizeof(DNode));
   L->prior=NULL;
   L->next=NULL;
   return true;
}
bool IsEmpty(DLinkList L){             //双链表判空
   if(L->next==NULL)
      return true;
   else
      return false;
}
bool DNodeInsert(DLinkList &L,int i,int e){    //双链表插入操作
   if(i<1)
      return false;
   DLinkList *p=L->next;
   int j=1;
   while(p&&j<=i-1){
      p=p->next;
      j++;
   }
   DLinkList *s=(DNode *)malloc(sizeof(DNode));
   s->data=e;
   s->next=p->next;
   if(p->next!=NULL)
      p->next->peior=s;
   s->prior=p;
   p->next=s;
   return true;
}
int DNodeDelete(DLinkList &L,int i,int &e){     //双链表删除操作
   if(i<1)                                      //位序i不合法
      return 0;
   DLinkList *p=L->next;
   int j=1;
   while(p->next&&j<=i-1){                     //找到第i-1位的双链表的结点
      p=p->next;
      j++;
   }
   DLinklist *q=p->next;
   e=q->data;
   p->next=q->next;
   if(q->next!=NULL)                          //判断去结点之后是否还有后继结点
      q->next->prior=p;
   free(q);
}
   
//循环单链表
typedef struct CNode{            //循环单链表结结点类型
   int data;
   struct CNode *next;
}CNode,*CLinkList;
bool InitCLinkList(CLinkList &L){   //循环单链表初始化
   L=(CNode *)malloc(sizeof(CNode));
   L->next=L;
   return true;
}
bool IsEmpty(CLinkList L){          //循环单链表判空
   return L->next==L;
}
bool IsTailCLinkList(CLinkList L,CNode *p){  //判断是否为表尾结点
   return p->next==L;
}

//循环双链表
typedef struct CDNode{          //循环双链表结点类型
   int data;
   struct CDNode *next,*prior;
}CDNode,*CDLinkList;
bool InitCDLinkList(CDLinkList &L){     //循环双链表初始化
   L=(CDNode *)malloc(sizeof(CDNode));
   L->next=L;
   L->prior=L;
   return true;
}
bool IsEmpty(CDLinkList L){             //双链表判空
 return L->next=L||L->prior=L;
}


//栈
//特点：先进后出（FILO）
/*先序序列为a，b，c，d的不同二叉树的个数、对n个不同元素进栈，出栈序列的个数、以及n个结点的二叉树有多少种不同形态等问题
都是卡特兰（Catalan）数1/(n+1)C(n)2n*/
#define MAXSIZE 10
typedef struct{                        //定义顺序栈数据结构
   int data[MAXSIZE};                  //定义整型数组存放栈中的元素
   int top;                            //定义栈顶指针
}SqStack;
bool InitStack(SqStack &S){            //初始化顺序栈
   for(int i=0;i<MAXSIZE-1;i++)
      S.data[i]=0;
   S.top=-1;
   return true;
}
bool IsEmpty(SqStack S){               //判断栈空
   return S.top==-1;
}
bool push(SqStack &S,int e){           //顺序栈入栈操作
   if(S.top=MAXSIZE-1)
      return false;
   S.data[++S.top]=e;
}
int pop(SqStack &S,int &e){            //顺序栈出栈
   if(S.top=-1)
      return 0;
   e=S.data[S.top--];
}
int GetTop(SqStack S,int &e){          //获取栈顶元素
   return e=S.data[S.top];
}

//共享栈
# define MAXSIZE 10
typedef Struct{                        //定义共享栈数据结构
   int data[MAXSIZE];
   int top;
}ShareStack;
bool InitShareStack(ShareStack &S1.ShareStack &S2){   //共享栈初始化
   for(int i=0;i<MAXSIZE-1;i++)
      S1.data[i]=0;
   S1.top=-1;
   S2.top=MAXSIZE;
}
bool IsEmpty(ShareStack S1,ShareStack S2){           //共享栈判空
   return S1.top=-1&&S2.top=MAXSIZE;
}
bool IsFull(ShareStack S1,ShareStack S2){            // 判断栈满
   return S1.top+1==S2.top;
}


//队列
//特点：先进先出（FIFO）
#define MAXSIZE 10
typedef struct{                    //定义循环队列的数据类型
   int data[MAXSIZE];              //定义整型数组存放队列数据
   int front,rear;                 //定义队头指针和队尾指针
   int tag;                        //定义状态标志位判断Q.front==Q.rear时队列是否为空
}CirQueue;
bool InitCirStack(CirStack &Q){    //循环队列初始化
   Q.front=Q.rear=0;
   Q.tag=0;
}
bool IsEmpty(CirStack Q){          //循环队列判空
   return Q.front==Q.rear&&Q.tag=0;
}
bool EnQueue(CirStack &Q,int e){   //循环队列插入队尾元素
   if(Q.front==Q.rear&&Q.tag==1)
      return false;
   Q.data[Q.rear]=e;
   Q.rear=(Q.rear+1)%MAXSIZE;
   Q.tag=1;
   return true;
}
int DeQueue(CirStack &Q,int &e){   //循环队列输出队头元素
   if(Q.front==Q.rear&&Q.tag==0)
      return0;
   e=Q.data[Q.front];
   Q.front=(Q.front+1)%MAXSIZE;
   Q.tag=0;
   return e;
}
int LenQueue(CirStak &Q,int &l){    //当前循环队列的长度
   return l=(Q.rear+MAXSIZE-Q.front)%MAXSIZE;
}


//链栈
//操作基本与单链表相同
typedef struct StackNode{          //定义链栈数据类型
   int data;
   struct StackNode *next;
}StackNode,*LinkStack;
bool InitLinkStack(LinkStack &ls){              //链栈初始化
   ls=(StackNode *)malloc(sizeof(StackNode));
   ls->next=NULL;
}
bool IsEmpty(LinkList ls){                      //链栈判空
   return ls->next==NULL;
}
bool StackInsert(LinkStack &ls,int e){          //链栈入栈
   StackNode *p=(StackNode *)malloc(sizeof(StackNode));
   p->data=e;                                   //头插法
   p->next=ls->next;
   ls->next=p;
}
int StackDelete(LinkStack &ls,int &e){         //链栈出栈
   StackNode *p=ls->next;
   e=p->data;
   ls->next=p->next;
   free(p);
}

//链队
typedef struct LinkNode{               //链式队列结点
   int data;
   struct LinkNode *next;
}LinkNode;
typedef struct{                       //链式队列
      LinkNode *front,*rear;          //指向链式队列队头和队尾的指针
}LinkQueue;
bool InitLinkQueue(LinkQueue &Q){                           //初始化链队列
   Q.front=Q.rear=(LinkNode *)malloc(sizeof(LinkNode));     //建立头结点
   Q.rear->next=NULL;
   return true;
}
bool IsEmpty(LinkQueue Q){                                  //链队列判空
   return Q.front==Q.rear==NULL;
}
bool DeLinkQueue(LinkQueue &Q){                             //销毁链队列
   while(Q.front){
      Q.rear=Q.front->next;
      free(Q.front);
      Q.front=Q.rear;
   }
   return true;
}
bool LinkQueueInsert(LinkQueue &Q,int e){                  //链队列队尾入队
   LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));
   s->data=e;
   s->next=Q.rear->next;
   Q.rear->next=s;
   Q.rear=Q.rear->next;
   return true;
}
int LinkNodeDe(LinkNode &Q,int &e){                        //链队列队头出队
   LinkNode *p=Q.front;
   Q->next=Q.front->next;
   Q.front=p->next;
   e=p->data;
   free(p);
}


//稀疏矩阵十字链表存储法
typedef struct OLNode{                 //十字链表法数据结构
   int i,j;                            //非零元素行和列下标
   int data;
   struct OLNode *right,*down;         //该非零元素所在的行表和列表的后继链域
}OLNode,*OLink；
bool InitOLNode(OLink &M){             //十字链表法初始化
   M=(OLNode *)malloc(sizeof(OLNode));
   M.i=5;
   M.j=5;                               //初始结点的行列下标分别存放矩阵的行数和列数
   M.data=6;                            //初始结点的数据域存放非零元素的个数
   M.right=NULL;
   M.down=NULL;
   return true;
}


//串
#define MAXSIZE 10
typedef struct{                         //定义串的数据结构
   char ch[MAXSIZE];                    //定义字符数组
   int length;                          //定义指针域
}SString;
bool InitStr(SString &S){               //串初始化
   for(int i=0;i<MAXSIZE;i++)
      S.ch[i]=0;
   S.length=0;
   return true;
}
bool StrCopy(SString &T,SString S){                     //串复制
   for(int i=0;i<S.length;i++){
      T.ch[i]=S.ch[i];
      T.legth++;
   }
return true;
}
bool IsEmpty(SString S){                                //串判空
   return S.length==0;
}
StrList StrCompare(SString S,SString T){                //串比较
   for(int i=0,j=0;i<S.length,j<T.length;i++,j++){
      if(S.ch[i]>T.ch[i])
         return S;
      else if(S.ch[i]<T.ch[i])
         return T;
      else
         continue;
   }
   return 0;
}
int StrLength(SString S){                                        //求串长
   return S.length;
}
StrList SubString(SString S,SString &T,int pos,int len){         //求子串
   if(pos<1||pos>S.length||len<0||len>S.length-pos)              //判断pos和len是否合法
      return 0;
   int j=0;
   for(int i=pos-1;i<=len;i++){
      T.ch[j]=S.ch[i];
      j++;
   }
   T.length=len;
   return T;
}
StrList Concat(SString S1,SString S2,SString &T){                 //串连接
   for(int i=0;i<S1.length;i++)
      T.ch[i]=S1.ch[i];
   for(int i=0;i<S2.length;i++)
      T.ch[i+S1.length]=S2.ch[i];
   T.length=S1.length+S2.length;
   return T;
}

//简单模式匹配算法
int Index(SString S,SString T){                                   //串定位
   int i=1,j=1;                                                   //定义指向两个串的指针
   while(i<=S.length&&j<=T.length){                               //设置循环条件
      if(S.ch[i-1]==T.ch[i-1]){                                   //字符相等则继续比较
         ++i;
         ++j;
      }else{                                                      //否则重置指针位置
         i=i-j+2；                                                //i的位置为S的当前位置减去T串长度再后移1位
         j=1;                                                     //j指向T串首字符
      }
      if(j>T.length)                                              //j>T.length意为S中有子串与模式串匹配成功
         return i-T.length;
      else
         return 0;
}
//代码时间复杂度为O(mn)

//KMP算法
//思想：主串指针不动而让子串的指针移动到可以继续匹配的字符位置
//例如模式串为abaabc，则next数组为next[1]=0，next[2]=1，next[3]=1，next[4]=2，next[5]=2，next[6]=3，算法如下
int Index_KMP(SString S,SString T,int next[]){                    //使用KMP算法进行串定位
   int i=1,j=1;
   while(i<=S.length&&j<=T.length){
      if(j=0||S.ch[i-1]==T.ch[j-1]){                              //配合数组next[1]，即第一个字符不匹配的情况
         ++i;
         ++j;
      }else{
         j=next[j];
      }
      if(j>T.length)
         return i-T.length;
      else
         return 0;
}
//代码时间复杂度为O(m+n)
//优化KMP算法
/*思想：如果匹配失败的字符和next数组中待匹配的字符相同，则该次匹配一定失败，可使模式串指针继续向前回溯。
因此，可使用优化的nextval数组代替next数组*/
/*例如模式串abaabc中，当第三个字符a不匹配时next数组会使模式串指针移动到第一个a字符位置，已知该处不是字
符a则此次移动必然不匹配，需再次移动指针到0的位置。所以，优化后的nextval[3]=0*/
//优化后的nextval数组为nextval[1]=0，nextval[2]=1，nextval[3]=0，nextval[4]=2，nextval[5]=1，nextval[6]=3
//求nextval数组的算法
nextval[1]=0;
for(int j=2;j<=T.length;j++){
   if(T.ch[next[j]]==T.ch[j])
      nextval[j]=nextval[next[j]];
   else
      netval[j]=next[j];
}


//树
//性质：1.结点数=总度数+1 2.度为m的树（或m叉树）第i层至多有m^(i-1)个结点 3.高度为h的m叉树至多有(m^h-1)/(m-1)个结点
// 4.高度为h的m叉树至少有h个结点 5.高度为h，度为m的树至少有h+m-1个结点 6.具有n个结点的m叉树的最小高度为⌈log_m(n(m-1)+1)⌉

//二叉树
/*性质：1.设非空二叉树中度为0，1，2的节点个数分别为n_0，n_1，n_2，则n_0=n_2+1。2.二叉树的第i层至多有2^(i-1)个结点。
3.高度为h的二叉树至多有2^h-1个结点。*/

//满二叉树：一颗高度为h，且含有2^h-1个结点的二叉树
//特点：1.只有最后一层有叶子结点。2.不存在度为1的结点。3.按层序从1开始编号，结点i的左孩子为2i、右孩子为2i+1、父结点为⌊i/2⌋

//完全二叉树：当且仅当其每个结点都与高度为h的满二叉树中编号为1~n的结点一一对应时，称为完全二叉树
//特点：1.只有最后两层有叶子结点。2.最多只有1个度为1的结点。3.i<=⌊n/2⌋为分支结点，i>⌊n/2⌋为叶子结点（n为完全二叉树中结点个数）
/*性质：1.具有n(n>0)个结点的完全二叉树的高度h为⌈log_2(n+1)⌉或⌊log_2(n)⌋+1。2.对于完全二叉树，可以由结点数n推出度为0、1和2的
结点个数为n_0、n_1和n_2，完全二叉树最多只有一个度为1的结点，即n_1=0或1；n_0+n_2一定是奇数。若完全二叉树有2k（偶数）个结点，
则必有n_1=1,n_0=k，n_2=k-1；若完全二叉树有2k+1（奇数）个结点，则必有n_1=0,n_0=k，n_2=k-1。*/

//二叉排序树：左子树结点编号均小于根结点，右子树结点编号均大于根结点，左子树和右子树友个是一棵二叉排序树

//平衡二叉树：任意结点的左子树和右子树高度只差不超过1（平衡因子）

//二叉树的链式存储
typedef struct BiTNode{                    //定义存储二叉树的数据类型
   int data;
   struct BiTNode *lchild,*rchild;         //定义指向左右孩子的指针
}BiTNode,* BiTree;
bool InitBiTree(BiTree &T){                //树结点的初始化
   T=(BiTNode *)malloc(sizeof(BiTNode));
   T->lchild=NULL;
   T->rchild=NULL;
   return true;
}                                           //n个结点的二叉链表共有n+1个空链域
void PreOrder(BiTree T){                    //二叉树的先序遍历（根左右）
   if(T!=NULL){
      visit(T);
      PreOrder(T->lchild);
      PreOrder(T->rchild);
   }
}
void InOrder(BiTree T){                     //二叉树中序遍历（左根右）
   if(T!=NULL){
      InOrder(T->lchild);
      visit(T);
      InOrder(T->rchild);
   }
}
void PostOrder(BiTree T){                   //二叉树后序遍历（左右根）
   if(T!=NULL){
      PostOrder(T->lchild);
      PostOrder(T->rchild);
      visit(T);
   }
}
//代码时间复杂度为O(h)，其中h为二叉树的高度
void LevelOrder(BiTree T){                   //二叉树的层序遍历
   LinkQueue Q;                              //定义一个链队列
   InitLinkQueue(Q);                         //初始化链队列
   EnLinkQueue(Q,T);                         //二叉树根结点入队
   BiTree p;
   while(!IsEmpty(Q)){                       //队列非空
      DeLinkQueue(Q,p);                      //队头元素出队
      visit(p);                              //访问出队元素
      if(p-lchild)
         EnLinkQueue(Q,p->lchild);           //左孩子非空则左孩子入队
      if(p->rchild)
         EnLinkQueue(Q,p->rchild);           //右孩子非空则右孩子入队
   }
}
//由遍历序列构造二叉树主要要确定根结点，再根据中序遍历序列划分左右子树

//线索二叉树
//当二叉树按照先序、中序、后序序列排列后，其中任意一个元素有且只有一个前驱和后继结点，可以利用叶子结点的(n+1)个空链域使二叉树线索化
typedef struct ThreadNode{               //定义线索二叉树的数据类型
   int data;
   struct ThreadNode *lchild,* rchild;
   int ltag,rtag;                        //定义左右孩子的标志位，ltag==0为孩子，ltag==1为前驱；rtag==0为孩子，rtag==1为后继
}ThreadNode,* ThreadTree;
//中序线索化
ThreadNode *pre=NULL;                    //定义指向访问当前结点的前驱的结点，初始指向NULL（pre是全局变量，否则需要加"&"）
void CreateInThread(ThreadTree T){       //中序线索化二叉树T
   if(T!=NULL)
      InThread(T);
   if(pre->rchild==NULL)                 //中序遍历完成后pre指向最后一个结点，需要单独进行处理
      pre->rtag=1;                       //pre的rtag置1，线索化完成
}
void InThread(ThreadTree T){             //中序遍历二叉树
   InThread(T->lchild);
   visit(T);
   InThread(T->rchild);
}
void visit(ThreadNode *q){                //在visit函数中对二叉树行中序线索化
   if(q->lchild==NULL){                   //pre结点是q结点的前驱，q的lchild指向中序前驱结点
      q->lchild=pre;
      q->ltag=1;
   }
   if(pre!=NULL&&pre->rchild==NULL){      //q结点是pre结点的后继，pre的rchild指向中序后继结点
      pre->rchild=q;
      pre->rtag=1;
   }
   pre=q;
}
//先序线索化
ThreadNode *pre=NULL;                    //定义指向访问当前结点的前驱的结点，初始指向NULL（pre是全局变量，否则需要加"&"）
void CreatePreThread(ThreadTree T){      //先序线索化二叉树T
   if(T!=NULL)
      PreThread(T);
   if(pre->rchild==NULL)                 //中序遍历完成后pre指向最后一个结点，需要单独进行处理
      pre->rtag=1;                       //pre的rtag置1，线索化完成
}
void PreThread(ThreadTree T){             //先序遍历二叉树
   visit(T);
   if(T->ltag==0)                         //lchild不是前驱结点
      PreThread(T->lchild);
   PreThread(T->rchild);
}
void visit(ThreadNode *q){                //在visit函数中对二叉树行先序线索化
   if(q->lchild==NULL){                   //pre结点是q结点的前驱，q的lchild指向中序前驱结点
      q->lchild=pre;
      q->ltag=1;
   }
   if(pre!=NULL&&pre->rchild==NULL){      //q结点是pre结点的后继，pre的rchild指向中序后继结点
      pre->rchild=q;
      pre->rtag=1;
   }
   pre=q;
}
