//顺序表
//特点：地址连续，依次存放，随机存取，类型相同
#define MAXSIZE 50
typedef struct{               //静态分配顺序表结构体定义  
   int data[MAXSIZE];         //定义存放数据的数组
   int length;                //数据指针
}SqList;                      //顺序表类型定义
//顺序表基本操作
bool InitSqList(SqList &L){   //顺序表初始化
   for(int i=0;i<MAXSIZE;i++) //数据域置0
      L.data[i]=0;
   L.length=0;                //表长为0
}
bool ListInsert(SqList &L,int i,int e){   //顺序表插入操作
   if(L.length>=Maxsize-1）               //判断顺序表是否存满
      return false;
   else if(i<1||i>L.length+1)             //判断插入的位序是否合法
      return false;
   for(int j=L.length;j>=i;j--)           //将位序在i之后的数组元素后移1位
      L.data[j]=L.data[j-1];
   L.data[i-1]=e;                         //将数据e的值赋值给数组下标为i-1的数组元素
   L.length++;                            //数据指针后移1位
   return true;
}
//代码段时间复杂度为O(n)
int ListDelete(SqList &L,int i,int &e){   //顺序表删除操作
   if(L.length<=0)                        //判断顺序表是否为空
      return 0;
   else if(i<1||i>L.length+1)             //判断删除的位序是否合法
      return 0;
   e=L.data[i-1];
   for(int j=i;j<L.length;j++)            //位序在i之后的元素前移1位
      L.data[j-1]=L.data[j];
   L.length--;                            //数据指针前移1位
   return e;
}
//代码段时间复杂度为O(n)
int LocateElem(SqList L,int e){           //顺序表按值查找
   for(int i=0;i<L.length;i++)
      if(L.data[i]==e)
         return i+1;                      //找到相同的值则返回其位序
}
//代码段时间复杂度为O(n)
int GetElem(SqList L,int i){              //顺序表按位序查找
   return L.data[i-1];                    //数组下标比位序少1
}
//代码段时间复杂度为O(1)

#define INITSIZE 10
typedef struct{               //动态分配顺序表结构体定义
   int *data;                 //指示动态分配的指针
   int length,maxsize;        //数组的当前长度和最大容量
}SqList;
bool InitList(SqList &L){                          //顺序表初始化
   L.data=(int *)malloc(INITSIZE*sizeof(int));     //分配INITSIZE个大小为int型的存储空间
   L.length=0;                                     //顺序表长度为0
   L.maxsize=INITSIZE;                             //顺序表最大能存储INITSIZE个数组数据
   return true;
}
bool IncreaseList(SqList &L,int len){              //增加顺序表的存储空间
   int *p=L.data;
   L.data=(int *)malloc((L.maxsize+len)*sizeof(int));
   for(int i=0;i<L.length;i++)
      L.data[i]=p[i];                              //把p指向的原来数据元素复制到新的空间
   L.maxsize+=len;
   free(p);
}
void PrintElem(SqList L){                          //打印顺序表的数据到屏幕
   for(int i=0;i<L.length;i++)
      printf("data[%d]=%d",i,L.data[i]);
}


//单链表
//特点：逻辑相邻的元素在物理位置上不相邻
typedef struct LNode{         //单链表结点结构体
   int data;                  //单链表数据域
   struct LNode *next;        //单链表指针域
}LNode,*LinkList;             //定义单链表结点类型
//单链表基本操作
bool InitList(LinkList &L){    //带头结点的单链表初始化
   L=(LNode *)malloc(sizeof(LNode));
   L->next=NULL;
   return true;
}
LinkList List_HeadInsert(LinkList &L){         //头插法建立单链表
   int x;
   scanf("%d",&x);
   while(x!='#'){
      LNode *s=(LNode *)malloc(sizeof(LNode));
      s->data=x;
      s->next=L->next;
      L->next=s;
      scanf("%d",&x);
   }
   return L;
}
//代码段时间复杂度为O(n)
LinkList List_TailInsert(Linklist &L){          //尾插法建立单链表
   int x;
   LNode *r=L->next;                            //增加一个尾指针r，使其始终指向单链表的尾结点
   scanf("%d",&x);
   while(x!='#'){
      LNode *s=(LNode *)malloc(sizeof(LNode));
      s->data=x;
      r->next=s;
      r=s;                                      //把新结点设置为新的尾结点
      scanf("%d",&x);
   }
   r->next=NULL;
   return L;
}
int GetElem(LinkList L,int i){       //按序号查找单链表结点的值
   LNode *p=L->next;
   int j=1;
   while(p&&j<i){
      p=p->next;
      j++;
   }
   return p->data;
}
//代码段时间复杂度为O(n)
LNode *LocateElem(LinkList L,int e){   //按值查找单链表结点
   LNode *p=L->next;
   while(p!=NULL&&p->data!=e)
      p=p->next;
   return p;
}
//代码段时间复杂度为O(n)
bool LNodeInsert(LinkList &L,int i,int e){          //单链表插入结点 
   if(i<1)
      return false;
   LNode *p=L->next;
   int j=1;
   while(p&&j<i-1){
      p=p->next;
      j++;
   }
   if(p==NULL)
      return false;
   LNode *s=(LNode *)malloc(sizeof(LNode));
   s->data=e;
   s->next=p->next;                                 //在第i-1位结点后插入新结点
   p->next=s;
   return true;
}
//代码段时间复杂度为O(n)
bool LNodeDelete(LinkList &L,int i,int &e){         //单链表删除结点
   if(i<1)
      return false;
   LNode *p=L->next;
   int j=1;
   while(p->next&&j<i-1){
      p=p->next;
      j++;
   }
   if(p==NULL)
      return false;
   LNode *q=p->next;
   p->next=q->next;
   free(q);
   return true;
}
//代码段时间复杂度为O(n)
int Length(LinkList L){         //求表长
   LNode *p=L->next;
   int i=1;
   while(P){
      i++;
      p=p->next;
   }
   return i;
}
//代码段时间复杂度为O(n)
bool DestoryList(LinkList &L){   //销毁单链表
   while(L->next){
     LNode *p=L->next;
      L->next=p->next;
      free(p);
   }
   free(L);
}

bool InitList(LinkList &L){     //不带头结点的单链表初始化
   L=NULL;
   return true;
}
bool LNodeInsert(LinkList &L;int i;int e){             //不带头结点的单链表的插入
   if(i<1)
      return false;
   if(i==1){
      LNode *s=(LNode *)malloc(sizeof(LNode));
      s->data=e;
      s->next=L;
      L=s;
      return true;
   }
   LNode *p=L;
   int j=1;
   while(p&&j<i-1){
      p=p->next;
      j++;
   }
   LNode *s=(LNode *)malloc(sizeof(LNode));
   s->data=e;
   s->next=p->next;                                 //在第i-1位结点后插入新结点
   p->next=s;
   return true;
}

//双链表
typedef struct DNode{                  //双链表结构体定义
   int data;                           //定义双链表数据域
   struct DNode *prior,*next;          //定义前向指针prior和后向指针next
}DNode,*DLinklist;                     //定义双链表名称
bool InitDLinkList(DLinkList &L){      //双链表初始化
   L=(DNode *)malloc(sizeof(DNode));
   L->prior=NULL;
   L->next=NULL;
   return true;
}
bool IsEmpty(DLinkList L){             //双链表判空
   if(L->next==NULL)
      return true;
   else
      return false;
}
bool DNodeInsert(DLinkList &L,int i,int e){    //双链表插入操作
   if(i<1)
      return false;
   DLinkList *p=L->next;
   int j=1;
   while(p&&j<=i-1){
      p=p->next;
      j++;
   }
   DLinkList *s=(DNode *)malloc(sizeof(DNode));
   s->data=e;
   s->next=p->next;
   if(p->next!=NULL)
      p->next->peior=s;
   s->prior=p;
   p->next=s;
   return true;
}
int DNodeDelete(DLinkList &L,int i,int &e){     //双链表删除操作
   if(i<1)                                      //位序i不合法
      return 0;
   DLinkList *p=L->next;
   int j=1;
   while(p->next&&j<=i-1){                     //找到第i-1位的双链表的结点
      p=p->next;
      j++;
   }
   DLinklist *q=p->next;
   e=q->data;
   p->next=q->next;
   if(q->next!=NULL)                          //判断去结点之后是否还有后继结点
      q->next->prior=p;
   free(q);
}
   
//循环单链表
typedef struct CNode{            //循环单链表结结点类型
   int data;
   struct CNode *next;
}CNode,*CLinkList;
bool InitCLinkList(CLinkList &L){   //循环单链表初始化
   L=(CNode *)malloc(sizeof(CNode));
   L->next=L;
   return true;
}
bool IsEmpty(CLinkList L){          //循环单链表判空
   return L->next==L;
}
bool IsTailCLinkList(CLinkList L,CNode *p){  //判断是否为表尾结点
   return p->next==L;
}

//循环双链表
typedef struct CDNode{          //循环双链表结点类型
   int data;
   struct CDNode *next,*prior;
}CDNode,*CDLinkList;
bool InitCDLinkList(CDLinkList &L){     //循环双链表初始化
   L=(CDNode *)malloc(sizeof(CDNode));
   L->next=L;
   L->prior=L;
   return true;
}
bool IsEmpty(CDLinkList L){             //双链表判空
 return L->next=L||L->prior=L;
}


//栈
//特点：先进后出（FILO）
/*先序序列为a，b，c，d的不同二叉树的个数、对n个不同元素进栈，出栈序列的个数、以及n个结点的二叉树有多少种不同形态等问题
都是卡特兰（Catalan）数1/(n+1)C(n)2n*/
#define MAXSIZE 10
typedef struct{                        //定义顺序栈数据结构
   int data[MAXSIZE};                  //定义整型数组存放栈中的元素
   int top;                            //定义栈顶指针
}SqStack;
bool InitStack(SqStack &S){            //初始化顺序栈
   for(int i=0;i<MAXSIZE-1;i++)
      S.data[i]=0;
   S.top=-1;
   return true;
}
bool IsEmpty(SqStack S){               //判断栈空
   return S.top==-1;
}
bool push(SqStack &S,int e){           //顺序栈入栈操作
   if(S.top=MAXSIZE-1)
      return false;
   S.data[++S.top]=e;
}
int pop(SqStack &S,int &e){            //顺序栈出栈
   if(S.top=-1)
      return 0;
   e=S.data[S.top--];
}
int GetTop(SqStack S,int &e){          //获取栈顶元素
   return e=S.data[S.top];
}

//共享栈
# define MAXSIZE 10
typedef Struct{                        //定义共享栈数据结构
   int data[MAXSIZE];
   int top;
}ShareStack;
bool InitShareStack(ShareStack &S1.ShareStack &S2){   //共享栈初始化
   for(int i=0;i<MAXSIZE-1;i++)
      S1.data[i]=0;
   S1.top=-1;
   S2.top=MAXSIZE;
}
bool IsEmpty(ShareStack S1,ShareStack S2){           //共享栈判空
   return S1.top=-1&&S2.top=MAXSIZE;
}
bool IsFull(ShareStack S1,ShareStack S2){            // 判断栈满
   return S1.top+1==S2.top;
}


//队列
//特点：先进先出（FIFO）
#define MAXSIZE 10
typedef struct{                    //定义循环队列的数据类型
   int data[MAXSIZE];              //定义整型数组存放队列数据
   int front,rear;                 //定义队头指针和队尾指针
   int tag;                        //定义状态标志位判断Q.front==Q.rear时队列是否为空
}CirQueue;
bool InitCirStack(CirStack &Q){    //循环队列初始化
   Q.front=Q.rear=0;
   Q.tag=0;
}
bool IsEmpty(CirStack Q){          //循环队列判空
   return Q.front==Q.rear&&Q.tag=0;
}
bool EnQueue(CirStack &Q,int e){   //循环队列插入队尾元素
   if(Q.front==Q.rear&&Q.tag==1)
      return false;
   Q.data[Q.rear]=e;
   Q.rear=(Q.rear+1)%MAXSIZE;
   Q.tag=1;
   return true;
}
int DeQueue(CirStack &Q,int &e){   //循环队列输出队头元素
   if(Q.front==Q.rear&&Q.tag==0)
      return0;
   e=Q.data[Q.front];
   Q.front=(Q.front+1)%MAXSIZE;
   Q.tag=0;
   return e;
}
int LenQueue(CirStak &Q,int &l){    //当前循环队列的长度
   return i=(Q.rear+MAXSIZE-Q.front)%MAXSIZE;
}


//链栈
//操作基本与单链表相同
typedef struct StackNode{          //定义链栈数据类型
   int data;
   struct StackNode *next;
}StackNode,*LinkStack;
bool InitLinkStack(LinkStack &ls){              //链栈初始化
   ls=(StackNode *)malloc(sizeof(StackNode));
   ls->next=NULL;
}
bool IsEmpty(LinkList ls){                      //链栈判空
   return ls->next==NULL;
}
bool StackInsert(LinkStack &ls,int e){          //链栈入栈
   StackNode *p=(StackNode *)malloc(sizeof(StackNode));
   p->data=e;                                   //头插法
   p->next=ls->next;
   ls->next=p;
}
int StackDelete(LinkStack &ls,int &e){         //链栈出栈
   StackNode *p=ls->next;
   e=p->data;
   ls->next=p->next;
   free(p);
}

//链队
typedef struct LinkNode{               //链式队列结点
   int data;
   struct LinkNode *next;
}LinkNode;
typedef struct{                       //链式队列
      LinkNode *front,*rear;          //指向链式队列队头和队尾的指针
}LinkQueue;
bool InitLinkQueue(LinkQueue &Q){                           //初始化链队列
   Q.front=Q.rear=(LinkNode *)malloc(sizeof(LinkNode));     //建立头结点
   Q.rear->next=NULL;
   return true;
}
bool IsEmpty(LinkQueue Q){                                  //链队列判空
   return Q.front==Q.rear==NULL;
}
bool DeLinkQueue(LinkQueue &Q){                             //销毁链队列
   while(Q.front){
      Q.rear=Q.front->next;
      free(Q.front);
      Q.front=Q.rear;
   }
   return true;
}
bool LinkQueueInsert(LinkQueue &Q,int e){                  //链队列队尾入队
   LinkNode *s=(LinkNode *)malloc(sizeof(LinkNode));
   s->data=e;
   s->next=Q.rear->next;
   Q.rear->next=s;
   Q.rear=Q.rear->next;
   return true;
}
int LinkNodeDe(LinkNode &Q,int &e){                        //链队列队头出队
   LinkNode *p=Q.front;
   Q->next=Q.front->next;
   Q.front=p->next;
   e=p->data;
   free(p);
}


//稀疏矩阵十字链表存储法
typedef struct OLNode{                 //十字链表法数据结构
   int i,j;                            //非零元素行和列下标
   int data;
   struct OLNode *right,*down;         //该非零元素所在的行表和列表的后继链域
}OLNode,*OLink；
bool InitOLNode(OLink &M){             //十字链表法初始化
   M=(OLNode *)malloc(sizeof(OLNode));
   M.i=5;
   M.j=5;                               //初始结点的行列下标存放矩阵的行数和列数
   M.data=5;                            //初始结点的数据域存放非零元素的个数
   M.right=NULL;
   M.down=NULL;
   return true;
}


//串
#define MAXSIZE 10
typedef struct{                         //定义串的数据结构
   char ch[MAXSIZE];                    //定义字符数组
   int length;                          //定义指针域
}SString;
bool InitStr(SString &S){               //串初始化
   for(int i=0;i<MAXSIZE;i++)
      S.ch[i]=0;
   S.length=0;
   return true;
}
bool StrCopy(SString &T,SString S){                     //串复制
   for(int i=0;i<S.length;i++){
      T.ch[i]=S.ch[i];
      T.legth++;
   }
return true;
}
bool IsEmpty(SString S){                                //串判空
   return S.length==0;
}
StrList StrCompare(SString S,SString T){                //串比较
   for(int i=0,j=0;i<S.length,j<T.length;i++,j++){
      if(S.ch[i]>T.ch[i])
         return S;
      else if(S.ch[i]<T.ch[i])
         return T;
      else
         continue;
   }
   return 0;
}
int StrLength(SString S){                                        //求串长
   return S.length;
}
StrList SubString(SString S,SString &T,int pos,int len){         //求子串
   if(pos<1||pos>S.length||len<0||len>S.length-pos)              //判断pos和len是否合法
      return 0;
   int j=0;
   for(int i=pos-1;i<=len;i++){
      T.ch[j]=S.ch[i];
      j++;
   }
   T.length=len;
   return T;
}
StrList Concat(SString S1,SString S2,SString &T){                 //串连接
   for(int i=0;i<S1.length;i++)
      T.ch[i]=S1.ch[i];
   for(int i=0;i<S2.length;i++)
      T.ch[i+S1.length]=S2.ch[i];
   T.length=S1.length+S2.length;
   return T;
}

//简单模式匹配算法
int Index(SString S,SString T){                                   //串定位
   int i=1,j=1;                                                   //定义指向两个串的指针
   while(i<=S.length&&j<=T.length){                               //设置循环条件
      if(S.ch[i-1]==T.ch[i-1]){                                   //字符相等则继续比较
         i++;
         j++;
      }else{                                                      //否则重置指针位置
         i=i-j+2；                                                //i的位置为S的当前位置减去T串长度再后移1位
         j=1;                                                     //j指向T串首字符
      }
      if(j>T.length)                                              //j>T.length意为S中有子串与模式串匹配成功
         return i-T.length;
      else
         return 0;
}
//此算法的时间复杂度为O(mn)

//KMP算法
//思想：主串指针不动而让子串的指针移动到可以继续匹配的字符位置
//例如模式串为abaabc，则next数组为011223，算法如下
int Index_KMP(SString S,SString T,int next[]){                    //使用KMP算法进行串定位
   int i=1,j=1;
   while(i<=S.length&&j<=T.length){
      if(S.ch[i-1]==T.ch[j-1]){
         i++;
         j++;
      }else{
         j=next[j];
      }
      if(j>T.length)
         return i-T.length;
      else
         return 0;
}
//此算法的时间复杂度为O(m+n)
